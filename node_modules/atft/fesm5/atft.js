import { Input, Injectable, Component, forwardRef, NgModule, EventEmitter, ContentChildren, ViewChildren, Output, ViewChild, HostListener, ContentChild, Pipe, Directive } from '@angular/core';
import { CommonModule } from '@angular/common';
import { __extends, __awaiter, __generator } from 'tslib';
import { WebGLRenderer, PCFSoftShadowMap, PerspectiveCamera, Geometry, DoubleSide, NormalBlending, Mesh, LineBasicMaterial, Line, AxesHelper, Object3D, GridHelper, Color, MeshLambertMaterial, MeshBasicMaterial, MeshPhongMaterial, Box3, Vector3, PointLight, HemisphereLight, DirectionalLight, ObjectLoader, Group, ShapeBufferGeometry, BoxGeometry, CylinderGeometry, Shape, PlaneBufferGeometry, SphereGeometry, TorusGeometry, FontLoader, TextGeometry, Scene, Fog, Raycaster } from 'three';
import { CSS3DRenderer, CSS3DObject } from 'three/examples/jsm/renderers/CSS3DRenderer';
import { MeshLine, MeshLineMaterial } from 'three.meshline';
import { OBJLoader } from 'three/examples/jsm/loaders/OBJLoader';
import { MTLLoader } from 'three/examples/jsm/loaders/MTLLoader';
import { SVGLoader } from 'three/examples/jsm/loaders/SVGLoader';
import { OrbitControls, MapControls } from 'three/examples/jsm/controls/OrbitControls';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @abstract
 * @template T
 */
var AbstractCamera = /** @class */ (function () {
    function AbstractCamera(rendererService) {
        this.rendererService = rendererService;
        this.zAxisUp = false;
        // console.log('AbstractCamera.constructor');
    }
    /**
     * @return {?}
     */
    AbstractCamera.prototype.ngAfterViewInit = /**
     * @return {?}
     */
    function () {
        // console.log('AbstractCamera.ngAfterViewInit');
        this.createCamera();
        this.applyZAxisUp();
        this.applyPosition();
        // TODO: Directive?
        this.rendererService.setCamera(this);
    };
    /**
     * @param {?} changes
     * @return {?}
     */
    AbstractCamera.prototype.ngOnChanges = /**
     * @param {?} changes
     * @return {?}
     */
    function (changes) {
        /** @type {?} */
        var mustRerender = false;
        if (['positionX', 'positionY', 'positionZ'].some((/**
         * @param {?} propName
         * @return {?}
         */
        function (propName) { return propName in changes; }))) {
            this.applyPosition();
            mustRerender = true;
        }
        if (mustRerender) {
            this.rendererService.render();
        }
    };
    /**
     * @protected
     * @return {?}
     */
    AbstractCamera.prototype.applyPosition = /**
     * @protected
     * @return {?}
     */
    function () {
        if (this.camera) {
            this.camera.position.set(this.positionX || 0, this.positionY || 0, this.positionZ || 0);
        }
    };
    /**
     * @protected
     * @return {?}
     */
    AbstractCamera.prototype.applyZAxisUp = /**
     * @protected
     * @return {?}
     */
    function () {
        if (this.camera && this.zAxisUp) {
            // Z axis up (similarly to 3D Creation Software: Blender, 3DS Max)
            this.camera.up.set(0, 0, 1);
        }
    };
    AbstractCamera.propDecorators = {
        positionX: [{ type: Input }],
        positionY: [{ type: Input }],
        positionZ: [{ type: Input }],
        zAxisUp: [{ type: Input }]
    };
    return AbstractCamera;
}());
if (false) {
    /** @type {?} */
    AbstractCamera.prototype.camera;
    /** @type {?} */
    AbstractCamera.prototype.positionX;
    /** @type {?} */
    AbstractCamera.prototype.positionY;
    /** @type {?} */
    AbstractCamera.prototype.positionZ;
    /** @type {?} */
    AbstractCamera.prototype.zAxisUp;
    /**
     * @type {?}
     * @protected
     */
    AbstractCamera.prototype.rendererService;
    /**
     * @abstract
     * @protected
     * @return {?}
     */
    AbstractCamera.prototype.createCamera = function () { };
    /**
     * @abstract
     * @param {?} aspect
     * @return {?}
     */
    AbstractCamera.prototype.updateAspectRatio = function (aspect) { };
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/* TODO: Refactor to pair
interface RendererPair {
  scene: SceneComponent;
  camera: AbstractCamera<any>;
  webGlRenderer: THREE.Renderer;
  layers: Array<number>;
}
*/
var RendererService = /** @class */ (function () {
    function RendererService() {
        this.init = false;
    }
    /**
     * @return {?}
     */
    RendererService.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
    };
    /**
     * @param {?} scene
     * @return {?}
     */
    RendererService.prototype.setScene = /**
     * @param {?} scene
     * @return {?}
     */
    function (scene) {
        this.scene = scene;
    };
    /**
     * @param {?} camera
     * @return {?}
     */
    RendererService.prototype.setCamera = /**
     * @param {?} camera
     * @return {?}
     */
    function (camera) {
        this.camera = camera;
        this.camera.updateAspectRatio(this.aspect);
    };
    /**
     * @return {?}
     */
    RendererService.prototype.render = /**
     * @return {?}
     */
    function () {
        if (this.init && this.scene && this.camera) {
            //  console.log('render');
            this.webGlRenderer.render(this.scene.getObject(), this.camera.camera);
            this.css3dRenderer.render(this.scene.getObject(), this.camera.camera);
        }
    };
    /**
     * @param {?} canvas
     * @return {?}
     */
    RendererService.prototype.initialize = /**
     * @param {?} canvas
     * @return {?}
     */
    function (canvas) {
        // console.log('RendererComponent.initialize');
        // TODO: Multiple renderers
        this.webGlRenderer = new WebGLRenderer({
            canvas: canvas,
            antialias: true,
            alpha: true
        });
        this.webGlRenderer.setPixelRatio(devicePixelRatio);
        this.webGlRenderer.setSize(canvas.clientWidth, canvas.clientHeight, false);
        // TODO: props
        this.webGlRenderer.shadowMap.enabled = false;
        this.webGlRenderer.shadowMap.autoUpdate = false;
        this.webGlRenderer.shadowMap.type = PCFSoftShadowMap;
        this.webGlRenderer.setClearColor(0x000000, 0);
        this.webGlRenderer.autoClear = true;
        canvas.style.zIndex = '2';
        // ------------------------------ START
        this.css3dRenderer = new CSS3DRenderer();
        this.css3dRenderer.setSize(window.innerWidth, window.innerHeight);
        this.css3dRenderer.domElement.style.position = 'absolute';
        this.css3dRenderer.domElement.style.top = '0';
        this.css3dRenderer.domElement.style.zIndex = '1';
        canvas.parentElement.appendChild(this.css3dRenderer.domElement);
        // ------------------------------ END
        this.updateChildCamerasAspectRatio(canvas);
        this.init = true;
        this.render();
    };
    /**
     * @param {?} canvas
     * @param {?} size
     * @return {?}
     */
    RendererService.prototype.resize = /**
     * @param {?} canvas
     * @param {?} size
     * @return {?}
     */
    function (canvas, size) {
        canvas.style.width = size;
        canvas.style.height = size;
        /** @type {?} */
        var width = canvas.clientWidth;
        /** @type {?} */
        var height = canvas.clientHeight;
        this.webGlRenderer.setSize(width, height, true);
        this.css3dRenderer.setSize(width, height);
        this.updateChildCamerasAspectRatio(canvas);
        this.render();
    };
    /**
     * @private
     * @param {?} canvas
     * @return {?}
     */
    RendererService.prototype.calculateAspectRatio = /**
     * @private
     * @param {?} canvas
     * @return {?}
     */
    function (canvas) {
        /** @type {?} */
        var height = canvas.clientHeight;
        if (height === 0) {
            return 0;
        }
        this.aspect = canvas.clientWidth / canvas.clientHeight;
    };
    /**
     * @private
     * @param {?} canvas
     * @return {?}
     */
    RendererService.prototype.updateChildCamerasAspectRatio = /**
     * @private
     * @param {?} canvas
     * @return {?}
     */
    function (canvas) {
        this.calculateAspectRatio(canvas);
        if (this.camera) {
            this.camera.updateAspectRatio(this.aspect);
        }
    };
    RendererService.decorators = [
        { type: Injectable }
    ];
    /** @nocollapse */
    RendererService.ctorParameters = function () { return []; };
    return RendererService;
}());
if (false) {
    /**
     * @type {?}
     * @private
     */
    RendererService.prototype.init;
    /**
     * @type {?}
     * @private
     */
    RendererService.prototype.scene;
    /**
     * @type {?}
     * @private
     */
    RendererService.prototype.camera;
    /**
     * @type {?}
     * @private
     */
    RendererService.prototype.webGlRenderer;
    /**
     * @type {?}
     * @private
     */
    RendererService.prototype.css3dRenderer;
    /**
     * @type {?}
     * @private
     */
    RendererService.prototype.aspect;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var PerspectiveCameraComponent = /** @class */ (function (_super) {
    __extends(PerspectiveCameraComponent, _super);
    function PerspectiveCameraComponent(rendererService) {
        var _this = _super.call(this, rendererService) || this;
        _this.rendererService = rendererService;
        return _this;
    }
    /**
     * @protected
     * @return {?}
     */
    PerspectiveCameraComponent.prototype.createCamera = /**
     * @protected
     * @return {?}
     */
    function () {
        // console.log('PerspectiveCameraComponent.createCamera');
        // let aspectRatio = undefined; // Updated later
        this.camera = new PerspectiveCamera(this.fov, undefined, this.near, this.far);
    };
    /**
     * @param {?} aspect
     * @return {?}
     */
    PerspectiveCameraComponent.prototype.updateAspectRatio = /**
     * @param {?} aspect
     * @return {?}
     */
    function (aspect) {
        // console.log('PerspectiveCameraComponent.updateAspectRatio: ' + aspect);
        this.camera.aspect = aspect;
        this.camera.updateProjectionMatrix();
    };
    PerspectiveCameraComponent.decorators = [
        { type: Component, args: [{
                    selector: 'atft-perspective-camera',
                    providers: [{ provide: AbstractCamera, useExisting: forwardRef((/**
                             * @return {?}
                             */
                            function () { return PerspectiveCameraComponent; })) }],
                    template: '<ng-content></ng-content>'
                }] }
    ];
    /** @nocollapse */
    PerspectiveCameraComponent.ctorParameters = function () { return [
        { type: RendererService }
    ]; };
    PerspectiveCameraComponent.propDecorators = {
        fov: [{ type: Input }],
        near: [{ type: Input }],
        far: [{ type: Input }]
    };
    return PerspectiveCameraComponent;
}(AbstractCamera));
if (false) {
    /** @type {?} */
    PerspectiveCameraComponent.prototype.fov;
    /** @type {?} */
    PerspectiveCameraComponent.prototype.near;
    /** @type {?} */
    PerspectiveCameraComponent.prototype.far;
    /**
     * @type {?}
     * @protected
     */
    PerspectiveCameraComponent.prototype.rendererService;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var AtftCameraModule = /** @class */ (function () {
    function AtftCameraModule() {
    }
    AtftCameraModule.decorators = [
        { type: NgModule, args: [{
                    declarations: [
                        PerspectiveCameraComponent
                    ],
                    imports: [
                        CommonModule
                    ],
                    exports: [
                        PerspectiveCameraComponent
                    ]
                },] }
    ];
    return AtftCameraModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @abstract
 * @template T
 */
var AbstractObject3D = /** @class */ (function () {
    function AbstractObject3D(rendererService) {
        var _this = this;
        this.rendererService = rendererService;
        this.changed = new EventEmitter();
        // console.log('AbstractObject3D.constructor');
        this.changed.subscribe((/**
         * @return {?}
         */
        function () {
            _this.rendererService.render();
        }));
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    AbstractObject3D.prototype.ngOnChanges = /**
     * @param {?} changes
     * @return {?}
     */
    function (changes) {
        if (!this.object) {
            return;
        }
        /** @type {?} */
        var modified = false;
        if (['rotateX', 'rotateY', 'rotateZ'].some((/**
         * @param {?} propName
         * @return {?}
         */
        function (propName) { return propName in changes; }))) {
            this.applyRotation();
            modified = true;
        }
        if (['translateX', 'translateY', 'translateZ'].some((/**
         * @param {?} propName
         * @return {?}
         */
        function (propName) { return propName in changes; }))) {
            this.applyTranslation();
            modified = true;
        }
        if (modified) {
            this.changed.emit();
        }
    };
    /**
     * @return {?}
     */
    AbstractObject3D.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        // console.log('AbstractObject3D.OnDestroy');
        if (this.object && this.object.parent) {
            this.object.parent.remove(this.object);
        }
    };
    /**
     * @return {?}
     */
    AbstractObject3D.prototype.ngAfterViewInit = /**
     * @return {?}
     */
    function () {
        // console.log('AbstractObject3D.ngAfterViewInit ' + this.name);
        this.object = this.newObject3DInstance();
        this.applyTranslation();
        this.applyRotation();
        this.collectChilds();
        this.afterInit();
    };
    /**
     * @return {?}
     */
    AbstractObject3D.prototype.collectChilds = /**
     * @return {?}
     */
    function () {
        var _this = this;
        // console.log('Collect childs for', this.name);
        if (this.childNodes !== undefined && this.childNodes.length > 1) {
            this.childNodes.filter((/**
             * @param {?} i
             * @return {?}
             */
            function (i) { return i !== _this && i.getObject() !== undefined; })).forEach((/**
             * @param {?} i
             * @return {?}
             */
            function (i) {
                // console.log('Add childNodes for', this.name, i);
                _this.addChild(i.getObject());
            }));
        }
        else {
            // console.log("No child Object3D for: " + this.constructor.label);
        }
        if (this.viewChilds !== undefined && this.viewChilds.length > 0) {
            this.viewChilds.filter((/**
             * @param {?} i
             * @return {?}
             */
            function (i) { return i !== _this
                && i.getObject() !== undefined
                && !i.getObject().parent; } /* direct childs only */)).forEach((/**
             * @param {?} i
             * @return {?}
             */
            function (i) {
                // console.log('Add viewChilds for', this.name, i);
                _this.addChild(i.getObject());
            }));
        }
        else {
            // console.log("No child Object3D for: " + this.constructor.label);
        }
    };
    /**
     * @private
     * @return {?}
     */
    AbstractObject3D.prototype.applyRotation = /**
     * @private
     * @return {?}
     */
    function () {
        this.object.rotation.set(this.rotateX || 0, this.rotateY || 0, this.rotateZ || 0, 'XYZ');
    };
    /**
     * @private
     * @return {?}
     */
    AbstractObject3D.prototype.applyTranslation = /**
     * @private
     * @return {?}
     */
    function () {
        this.object.position.set(this.translateX || 0, this.translateY || 0, this.translateZ || 0);
    };
    /**
     * @param {?} object
     * @return {?}
     */
    AbstractObject3D.prototype.addChild = /**
     * @param {?} object
     * @return {?}
     */
    function (object) {
        this.object.add(object);
    };
    /**
     * @protected
     * @param {?} object
     * @return {?}
     */
    AbstractObject3D.prototype.removeChild = /**
     * @protected
     * @param {?} object
     * @return {?}
     */
    function (object) {
        this.object.remove(object);
    };
    /**
     * @return {?}
     */
    AbstractObject3D.prototype.getObject = /**
     * @return {?}
     */
    function () {
        return this.object;
    };
    /**
     * @protected
     * @return {?}
     */
    AbstractObject3D.prototype.afterInit = /**
     * @protected
     * @return {?}
     */
    function () {
        // this.changed.emit();
    };
    AbstractObject3D.propDecorators = {
        childNodes: [{ type: ContentChildren, args: [AbstractObject3D, { descendants: false },] }],
        viewChilds: [{ type: ViewChildren, args: [AbstractObject3D,] }],
        rotateX: [{ type: Input }],
        rotateY: [{ type: Input }],
        rotateZ: [{ type: Input }],
        translateX: [{ type: Input }],
        translateY: [{ type: Input }],
        translateZ: [{ type: Input }],
        name: [{ type: Input }],
        changed: [{ type: Output }]
    };
    return AbstractObject3D;
}());
if (false) {
    /** @type {?} */
    AbstractObject3D.prototype.childNodes;
    /** @type {?} */
    AbstractObject3D.prototype.viewChilds;
    /**
     * Rotation in Euler angles (radians) with order X, Y, Z.
     * @type {?}
     */
    AbstractObject3D.prototype.rotateX;
    /** @type {?} */
    AbstractObject3D.prototype.rotateY;
    /** @type {?} */
    AbstractObject3D.prototype.rotateZ;
    /**
     * Translate the geometry. This is typically done as a one time operation, and not during a loop.
     * @type {?}
     */
    AbstractObject3D.prototype.translateX;
    /** @type {?} */
    AbstractObject3D.prototype.translateY;
    /** @type {?} */
    AbstractObject3D.prototype.translateZ;
    /** @type {?} */
    AbstractObject3D.prototype.name;
    /** @type {?} */
    AbstractObject3D.prototype.changed;
    /**
     * @type {?}
     * @private
     */
    AbstractObject3D.prototype.object;
    /**
     * @type {?}
     * @protected
     */
    AbstractObject3D.prototype.rendererService;
    /**
     * @abstract
     * @protected
     * @return {?}
     */
    AbstractObject3D.prototype.newObject3DInstance = function () { };
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @abstract
 * @template T
 */
var AbstractConnector = /** @class */ (function (_super) {
    __extends(AbstractConnector, _super);
    function AbstractConnector() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * @protected
     * @return {?}
     */
    AbstractConnector.prototype.newObject3DInstance = /**
     * @protected
     * @return {?}
     */
    function () {
        /** @type {?} */
        var mesh = this.createConnectorObject();
        this.watchObjects();
        return mesh;
    };
    /**
     * @private
     * @return {?}
     */
    AbstractConnector.prototype.watchObjects = /**
     * @private
     * @return {?}
     */
    function () {
        var _this = this;
        this.source.changed.subscribe((/**
         * @param {?} item
         * @return {?}
         */
        function (item) {
            _this.updateLineGeometry();
        }));
        this.target.changed.subscribe((/**
         * @param {?} item
         * @return {?}
         */
        function (item) {
            _this.updateLineGeometry();
        }));
    };
    /**
     * @protected
     * @return {?}
     */
    AbstractConnector.prototype.getLineGeometry = /**
     * @protected
     * @return {?}
     */
    function () {
        /** @type {?} */
        var geo = new Geometry();
        if (!this.source || !this.target) {
            throw new Error('AbstractConnector: source or target inputs are missing!');
        }
        geo.vertices.push(this.source.getObject().position);
        geo.vertices.push(this.target.getObject().position);
        return geo;
    };
    AbstractConnector.propDecorators = {
        source: [{ type: Input }],
        target: [{ type: Input }]
    };
    return AbstractConnector;
}(AbstractObject3D));
if (false) {
    /** @type {?} */
    AbstractConnector.prototype.source;
    /** @type {?} */
    AbstractConnector.prototype.target;
    /**
     * Create line mesh
     * @abstract
     * @return {?}
     */
    AbstractConnector.prototype.createConnectorObject = function () { };
    /**
     * If at least one line end (source or target object)  changed, then line geoetry should be updated as well
     * // TODO: Calculate only when source/target positions were changed
     * @abstract
     * @return {?}
     */
    AbstractConnector.prototype.updateLineGeometry = function () { };
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Fix color number binding issues
 * @param {?} color Color number from binding input
 * @param {?=} defaultColor default value in case of binding issues
 * @return {?}
 */
function appliedColor(color, defaultColor) {
    /** @type {?} */
    var resultColor = (defaultColor ? defaultColor : 0xffffff);
    if (color !== undefined) {
        resultColor = color * 1;
    }
    return resultColor;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Animation service emits animate event, which should be used by animated components for animation logic.
 * NOTE: this service is for the performance optimization: requestAnimationFrame and render is called once.
 */
var AnimationService = /** @class */ (function () {
    function AnimationService(rendererService) {
        this.rendererService = rendererService;
        /**
         * Subscribe for animation frame creation (change position and etc.)
         * Avoid render() execution, it's called only once when all components updated animation frame.
         */
        this.animate = new EventEmitter();
        this.enabled = false;
        this.animationStep = this.animationStep.bind(this);
    }
    /**
     * Start the animation loop.
     */
    /**
     * Start the animation loop.
     * @return {?}
     */
    AnimationService.prototype.start = /**
     * Start the animation loop.
     * @return {?}
     */
    function () {
        if (!this.enabled) {
            this.enabled = true;
            this.animationStep();
        }
    };
    /**
     * Stop all animations.
     */
    /**
     * Stop all animations.
     * @return {?}
     */
    AnimationService.prototype.stop = /**
     * Stop all animations.
     * @return {?}
     */
    function () {
        if (this.enabled) {
            this.enabled = false;
        }
    };
    /**
     * @private
     * @return {?}
     */
    AnimationService.prototype.animationStep = /**
     * @private
     * @return {?}
     */
    function () {
        if (this.enabled) {
            requestAnimationFrame(this.animationStep);
            if (this.animate.observers.length > 0) {
                this.animate.emit();
                /**
                 * When all components updated animation, render event is emitted.
                 * Main renderer subscribed to this event emitter.
                 */
                this.rendererService.render();
            }
        }
    };
    AnimationService.decorators = [
        { type: Injectable }
    ];
    /** @nocollapse */
    AnimationService.ctorParameters = function () { return [
        { type: RendererService }
    ]; };
    return AnimationService;
}());
if (false) {
    /**
     * Subscribe for animation frame creation (change position and etc.)
     * Avoid render() execution, it's called only once when all components updated animation frame.
     * @type {?}
     */
    AnimationService.prototype.animate;
    /**
     * @type {?}
     * @private
     */
    AnimationService.prototype.enabled;
    /**
     * @type {?}
     * @private
     */
    AnimationService.prototype.rendererService;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var MeshLineConnectorComponent = /** @class */ (function (_super) {
    __extends(MeshLineConnectorComponent, _super);
    function MeshLineConnectorComponent(animationService, rendererService) {
        var _this = _super.call(this, rendererService) || this;
        _this.animationService = animationService;
        _this.rendererService = rendererService;
        _this.materialColor = 0xffff00;
        _this.transparent = true;
        _this.opacity = 0.5;
        _this.lineWidth = 0.5;
        _this.depthWrite = true;
        _this.depthTest = true;
        _this.animated = false;
        _this.animationIncrement = 0.002;
        return _this;
    }
    /**
     * @return {?}
     */
    MeshLineConnectorComponent.prototype.createConnectorObject = /**
     * @return {?}
     */
    function () {
        this.geometry = this.getLineGeometry();
        this.line = new MeshLine();
        this.line.setGeometry(this.geometry);
        this.lineMaterial = (this.animated ?
            new MeshLineMaterial({
                color: appliedColor(this.materialColor),
                transparent: this.transparent,
                opacity: this.opacity,
                lineWidth: this.lineWidth,
                depthWrite: this.depthWrite,
                depthTest: this.depthTest,
                side: DoubleSide,
                blending: NormalBlending,
                // TODO: props
                dashArray: 0.05,
                dashOffset: 0.1,
                dashRatio: 0.1
            })
            : new MeshLineMaterial({
                color: appliedColor(this.materialColor),
                transparent: this.transparent,
                opacity: this.opacity,
                lineWidth: this.lineWidth,
                depthWrite: this.depthWrite,
                depthTest: this.depthTest,
                side: DoubleSide,
                blending: NormalBlending
            }));
        /** @type {?} */
        var mesh = new Mesh(this.line.geometry, this.lineMaterial);
        if (this.animated) {
            this.animate = this.animate.bind(this);
            this.animationService.animate.subscribe(this.animate);
        }
        return mesh;
    };
    /**
     * @private
     * @return {?}
     */
    MeshLineConnectorComponent.prototype.animate = /**
     * @private
     * @return {?}
     */
    function () {
        this.lineMaterial.uniforms.dashOffset.value += this.animationIncrement;
    };
    /**
     * @return {?}
     */
    MeshLineConnectorComponent.prototype.updateLineGeometry = /**
     * @return {?}
     */
    function () {
        // https://github.com/spite/THREE.MeshLine/issues/51#issuecomment-379579926
        this.line.setGeometry(this.geometry);
        this.rendererService.render();
    };
    MeshLineConnectorComponent.decorators = [
        { type: Component, args: [{
                    selector: 'atft-mesh-line-connector',
                    providers: [{ provide: AbstractObject3D, useExisting: forwardRef((/**
                             * @return {?}
                             */
                            function () { return MeshLineConnectorComponent; })) }],
                    template: '<ng-content></ng-content>'
                }] }
    ];
    /** @nocollapse */
    MeshLineConnectorComponent.ctorParameters = function () { return [
        { type: AnimationService },
        { type: RendererService }
    ]; };
    MeshLineConnectorComponent.propDecorators = {
        materialColor: [{ type: Input }],
        transparent: [{ type: Input }],
        opacity: [{ type: Input }],
        lineWidth: [{ type: Input }],
        depthWrite: [{ type: Input }],
        depthTest: [{ type: Input }],
        animated: [{ type: Input }],
        animationIncrement: [{ type: Input }]
    };
    return MeshLineConnectorComponent;
}(AbstractConnector));
if (false) {
    /** @type {?} */
    MeshLineConnectorComponent.prototype.materialColor;
    /** @type {?} */
    MeshLineConnectorComponent.prototype.transparent;
    /** @type {?} */
    MeshLineConnectorComponent.prototype.opacity;
    /** @type {?} */
    MeshLineConnectorComponent.prototype.lineWidth;
    /** @type {?} */
    MeshLineConnectorComponent.prototype.depthWrite;
    /** @type {?} */
    MeshLineConnectorComponent.prototype.depthTest;
    /** @type {?} */
    MeshLineConnectorComponent.prototype.animated;
    /** @type {?} */
    MeshLineConnectorComponent.prototype.animationIncrement;
    /**
     * @type {?}
     * @private
     */
    MeshLineConnectorComponent.prototype.geometry;
    /**
     * @type {?}
     * @private
     */
    MeshLineConnectorComponent.prototype.line;
    /**
     * @type {?}
     * @private
     */
    MeshLineConnectorComponent.prototype.lineMaterial;
    /**
     * @type {?}
     * @protected
     */
    MeshLineConnectorComponent.prototype.animationService;
    /**
     * @type {?}
     * @protected
     */
    MeshLineConnectorComponent.prototype.rendererService;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var LineConnectorComponent = /** @class */ (function (_super) {
    __extends(LineConnectorComponent, _super);
    function LineConnectorComponent(rendererService) {
        var _this = _super.call(this, rendererService) || this;
        _this.rendererService = rendererService;
        _this.materialColor = 0xffff00;
        return _this;
    }
    /**
     * @return {?}
     */
    LineConnectorComponent.prototype.createConnectorObject = /**
     * @return {?}
     */
    function () {
        this.geometry = this.getLineGeometry();
        /** @type {?} */
        var material = new LineBasicMaterial({
            color: appliedColor(this.materialColor),
            /**
             * NOTE: linewidth=1: Due to limitations of the OpenGL Core Profile
             * with the WebGL renderer on most platforms linewidth will always be 1
             * regardless of the set value.
             */
            linewidth: 1
        });
        /** @type {?} */
        var line = new Line(this.geometry, material);
        return line;
    };
    /**
     * @return {?}
     */
    LineConnectorComponent.prototype.updateLineGeometry = /**
     * @return {?}
     */
    function () {
        this.geometry.verticesNeedUpdate = true;
        this.rendererService.render();
    };
    LineConnectorComponent.decorators = [
        { type: Component, args: [{
                    selector: 'atft-line-connector',
                    providers: [{ provide: AbstractObject3D, useExisting: forwardRef((/**
                             * @return {?}
                             */
                            function () { return LineConnectorComponent; })) }],
                    template: '<ng-content></ng-content>'
                }] }
    ];
    /** @nocollapse */
    LineConnectorComponent.ctorParameters = function () { return [
        { type: RendererService }
    ]; };
    LineConnectorComponent.propDecorators = {
        materialColor: [{ type: Input }]
    };
    return LineConnectorComponent;
}(AbstractConnector));
if (false) {
    /** @type {?} */
    LineConnectorComponent.prototype.materialColor;
    /**
     * @type {?}
     * @private
     */
    LineConnectorComponent.prototype.geometry;
    /**
     * @type {?}
     * @protected
     */
    LineConnectorComponent.prototype.rendererService;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var AtftConnectorModule = /** @class */ (function () {
    function AtftConnectorModule() {
    }
    AtftConnectorModule.decorators = [
        { type: NgModule, args: [{
                    declarations: [
                        LineConnectorComponent,
                        MeshLineConnectorComponent
                    ],
                    imports: [
                        CommonModule
                    ],
                    exports: [
                        LineConnectorComponent,
                        MeshLineConnectorComponent
                    ]
                },] }
    ];
    return AtftConnectorModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var AxesHelperComponent = /** @class */ (function (_super) {
    __extends(AxesHelperComponent, _super);
    function AxesHelperComponent(rendererService) {
        var _this = _super.call(this, rendererService) || this;
        _this.rendererService = rendererService;
        return _this;
    }
    /**
     * @protected
     * @return {?}
     */
    AxesHelperComponent.prototype.newObject3DInstance = /**
     * @protected
     * @return {?}
     */
    function () {
        // console.log('AxesHelperComponent.newObject3DInstance');
        return new AxesHelper(this.size);
    };
    AxesHelperComponent.decorators = [
        { type: Component, args: [{
                    selector: 'atft-axes-helper',
                    providers: [{ provide: AbstractObject3D, useExisting: forwardRef((/**
                             * @return {?}
                             */
                            function () { return AxesHelperComponent; })) }],
                    template: '<ng-content></ng-content>'
                }] }
    ];
    /** @nocollapse */
    AxesHelperComponent.ctorParameters = function () { return [
        { type: RendererService }
    ]; };
    AxesHelperComponent.propDecorators = {
        size: [{ type: Input }]
    };
    return AxesHelperComponent;
}(AbstractObject3D));
if (false) {
    /** @type {?} */
    AxesHelperComponent.prototype.size;
    /**
     * @type {?}
     * @protected
     */
    AxesHelperComponent.prototype.rendererService;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var EmptyComponent = /** @class */ (function (_super) {
    __extends(EmptyComponent, _super);
    function EmptyComponent(rendererService) {
        var _this = _super.call(this, rendererService) || this;
        _this.rendererService = rendererService;
        return _this;
    }
    /**
     * @protected
     * @return {?}
     */
    EmptyComponent.prototype.newObject3DInstance = /**
     * @protected
     * @return {?}
     */
    function () {
        return new Object3D();
    };
    EmptyComponent.decorators = [
        { type: Component, args: [{
                    selector: 'atft-empty',
                    providers: [{ provide: AbstractObject3D, useExisting: forwardRef((/**
                             * @return {?}
                             */
                            function () { return EmptyComponent; })) }],
                    template: '<ng-content></ng-content>'
                }] }
    ];
    /** @nocollapse */
    EmptyComponent.ctorParameters = function () { return [
        { type: RendererService }
    ]; };
    return EmptyComponent;
}(AbstractObject3D));
if (false) {
    /**
     * @type {?}
     * @protected
     */
    EmptyComponent.prototype.rendererService;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var GridHelperComponent = /** @class */ (function (_super) {
    __extends(GridHelperComponent, _super);
    function GridHelperComponent(rendererService) {
        var _this = _super.call(this, rendererService) || this;
        _this.rendererService = rendererService;
        return _this;
    }
    /**
     * @protected
     * @return {?}
     */
    GridHelperComponent.prototype.newObject3DInstance = /**
     * @protected
     * @return {?}
     */
    function () {
        // console.log('GridHelperComponent.newObject3DInstance');
        return new GridHelper(this.size, this.divisions);
    };
    GridHelperComponent.decorators = [
        { type: Component, args: [{
                    selector: 'atft-grid-helper',
                    providers: [{ provide: AbstractObject3D, useExisting: forwardRef((/**
                             * @return {?}
                             */
                            function () { return GridHelperComponent; })) }],
                    template: '<ng-content></ng-content>'
                }] }
    ];
    /** @nocollapse */
    GridHelperComponent.ctorParameters = function () { return [
        { type: RendererService }
    ]; };
    GridHelperComponent.propDecorators = {
        size: [{ type: Input }],
        divisions: [{ type: Input }]
    };
    return GridHelperComponent;
}(AbstractObject3D));
if (false) {
    /** @type {?} */
    GridHelperComponent.prototype.size;
    /** @type {?} */
    GridHelperComponent.prototype.divisions;
    /**
     * @type {?}
     * @protected
     */
    GridHelperComponent.prototype.rendererService;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var AtftHelperModule = /** @class */ (function () {
    function AtftHelperModule() {
    }
    AtftHelperModule.decorators = [
        { type: NgModule, args: [{
                    declarations: [
                        AxesHelperComponent,
                        EmptyComponent,
                        GridHelperComponent
                    ],
                    imports: [
                        CommonModule
                    ],
                    exports: [
                        AxesHelperComponent,
                        EmptyComponent,
                        GridHelperComponent
                    ]
                },] }
    ];
    return AtftHelperModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Creates material
 *
 * @param {?} materialColor color
 * @param {?=} materialName material label as string
 * @param {?=} depthWrite enable depth write
 * @return {?}
 */
function appliedMaterial(materialColor, materialName, depthWrite) {
    /** @type {?} */
    var props = {
        color: (materialColor instanceof Color ? materialColor : appliedColor(materialColor)),
        side: DoubleSide,
        depthWrite: (depthWrite !== undefined ? depthWrite : true)
    };
    if (materialName === 'lamb') {
        return new MeshLambertMaterial(props);
    }
    else if (materialName === 'basic') {
        return new MeshBasicMaterial(props);
    }
    else {
        return new MeshPhongMaterial(props);
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} group
 * @return {?}
 */
function calculateSize(group) {
    /** @type {?} */
    var box = new Box3().setFromObject(group);
    return new Vector3(box.max.x - box.min.x, box.max.y - box.min.y, box.max.z - box.min.z);
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} group
 * @return {?}
 */
function fixCenter(group) {
    /** @type {?} */
    var box = calculateSize(group);
    group.translateX(-box.x / 2);
    group.translateY(-box.y / 2);
    group.translateZ(-box.z / 2);
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} group
 * @param {?} max
 * @return {?}
 */
function scaleToFit(group, max) {
    /** @type {?} */
    var box = calculateSize(group);
    /** @type {?} */
    var scaleX = max.x / box.x;
    /** @type {?} */
    var scaleY = max.y / box.y;
    /** @type {?} */
    var scaleZ = max.z / box.z;
    group.scale.set((scaleX < 1 ? scaleX : 1), (scaleY < 1 ? scaleY : 1), (scaleZ < 1 ? scaleZ : 1));
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var PointLightComponent = /** @class */ (function (_super) {
    __extends(PointLightComponent, _super);
    function PointLightComponent(rendererService) {
        var _this = _super.call(this, rendererService) || this;
        _this.rendererService = rendererService;
        _this.color = 0xffffff;
        _this.intensity = 1;
        _this.distance = 500;
        _this.castShadow = false;
        return _this;
    }
    /**
     * @protected
     * @return {?}
     */
    PointLightComponent.prototype.newObject3DInstance = /**
     * @protected
     * @return {?}
     */
    function () {
        /** @type {?} */
        var light = new PointLight(appliedColor(this.color), this.intensity, this.distance);
        if (this.castShadow === true) {
            light.castShadow = this.castShadow;
            // TODO: props
            light.shadow.mapSize.width = 1024;
            light.shadow.mapSize.height = 1024;
            light.shadow.camera.near = 0.5;
            light.shadow.camera.far = 500;
            light.shadow.bias = -0.001;
            light.shadow.radius = 1;
        }
        return light;
    };
    PointLightComponent.decorators = [
        { type: Component, args: [{
                    selector: 'atft-point-light',
                    providers: [{ provide: AbstractObject3D, useExisting: forwardRef((/**
                             * @return {?}
                             */
                            function () { return PointLightComponent; })) }],
                    template: '<ng-content></ng-content>'
                }] }
    ];
    /** @nocollapse */
    PointLightComponent.ctorParameters = function () { return [
        { type: RendererService }
    ]; };
    PointLightComponent.propDecorators = {
        color: [{ type: Input }],
        intensity: [{ type: Input }],
        distance: [{ type: Input }],
        castShadow: [{ type: Input }]
    };
    return PointLightComponent;
}(AbstractObject3D));
if (false) {
    /** @type {?} */
    PointLightComponent.prototype.color;
    /** @type {?} */
    PointLightComponent.prototype.intensity;
    /** @type {?} */
    PointLightComponent.prototype.distance;
    /** @type {?} */
    PointLightComponent.prototype.castShadow;
    /**
     * @type {?}
     * @protected
     */
    PointLightComponent.prototype.rendererService;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var HemisphereLightComponent = /** @class */ (function (_super) {
    __extends(HemisphereLightComponent, _super);
    function HemisphereLightComponent(rendererService) {
        var _this = _super.call(this, rendererService) || this;
        _this.rendererService = rendererService;
        _this.skyColor = 0xffffff;
        _this.groundColor = 0x444444;
        _this.intensity = 1;
        return _this;
    }
    /**
     * @protected
     * @return {?}
     */
    HemisphereLightComponent.prototype.newObject3DInstance = /**
     * @protected
     * @return {?}
     */
    function () {
        /** @type {?} */
        var light = new HemisphereLight(appliedColor(this.skyColor), appliedColor(this.groundColor), appliedColor(this.intensity));
        return light;
    };
    HemisphereLightComponent.decorators = [
        { type: Component, args: [{
                    selector: 'atft-hemisphere-light',
                    providers: [{ provide: AbstractObject3D, useExisting: forwardRef((/**
                             * @return {?}
                             */
                            function () { return HemisphereLightComponent; })) }],
                    template: '<ng-content></ng-content>'
                }] }
    ];
    /** @nocollapse */
    HemisphereLightComponent.ctorParameters = function () { return [
        { type: RendererService }
    ]; };
    HemisphereLightComponent.propDecorators = {
        skyColor: [{ type: Input }],
        groundColor: [{ type: Input }],
        intensity: [{ type: Input }]
    };
    return HemisphereLightComponent;
}(AbstractObject3D));
if (false) {
    /** @type {?} */
    HemisphereLightComponent.prototype.skyColor;
    /** @type {?} */
    HemisphereLightComponent.prototype.groundColor;
    /** @type {?} */
    HemisphereLightComponent.prototype.intensity;
    /**
     * @type {?}
     * @protected
     */
    HemisphereLightComponent.prototype.rendererService;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var DirectionalLightComponent = /** @class */ (function (_super) {
    __extends(DirectionalLightComponent, _super);
    function DirectionalLightComponent(rendererService) {
        var _this = _super.call(this, rendererService) || this;
        _this.rendererService = rendererService;
        _this.color = 0xffffff;
        _this.intensity = 1;
        // by default, target is 0,0,0
        _this.target = new Object3D();
        _this.castShadow = true;
        return _this;
    }
    /**
     * @protected
     * @return {?}
     */
    DirectionalLightComponent.prototype.newObject3DInstance = /**
     * @protected
     * @return {?}
     */
    function () {
        /** @type {?} */
        var light = new DirectionalLight(appliedColor(this.color), this.intensity);
        light.target = this.target;
        if (this.castShadow === true) {
            light.castShadow = this.castShadow;
            // TODO: props
            light.shadow.camera.top = 100;
            light.shadow.camera.bottom = -100;
            light.shadow.camera.left = -100;
            light.shadow.camera.right = 100;
            light.shadow.camera.near = 0.1;
            light.shadow.camera.far = 500;
            light.shadow.mapSize.set(1024, 1024);
            light.shadow.bias = -0.001;
        }
        return light;
    };
    DirectionalLightComponent.decorators = [
        { type: Component, args: [{
                    selector: 'atft-directional-light',
                    providers: [{ provide: AbstractObject3D, useExisting: forwardRef((/**
                             * @return {?}
                             */
                            function () { return DirectionalLightComponent; })) }],
                    template: '<ng-content></ng-content>'
                }] }
    ];
    /** @nocollapse */
    DirectionalLightComponent.ctorParameters = function () { return [
        { type: RendererService }
    ]; };
    DirectionalLightComponent.propDecorators = {
        color: [{ type: Input }],
        intensity: [{ type: Input }],
        target: [{ type: Input }],
        castShadow: [{ type: Input }]
    };
    return DirectionalLightComponent;
}(AbstractObject3D));
if (false) {
    /** @type {?} */
    DirectionalLightComponent.prototype.color;
    /** @type {?} */
    DirectionalLightComponent.prototype.intensity;
    /** @type {?} */
    DirectionalLightComponent.prototype.target;
    /** @type {?} */
    DirectionalLightComponent.prototype.castShadow;
    /**
     * @type {?}
     * @protected
     */
    DirectionalLightComponent.prototype.rendererService;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var AtftLightModule = /** @class */ (function () {
    function AtftLightModule() {
    }
    AtftLightModule.decorators = [
        { type: NgModule, args: [{
                    declarations: [
                        DirectionalLightComponent,
                        HemisphereLightComponent,
                        PointLightComponent
                    ],
                    imports: [
                        CommonModule
                    ],
                    exports: [
                        DirectionalLightComponent,
                        HemisphereLightComponent,
                        PointLightComponent
                    ]
                },] }
    ];
    return AtftLightModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @abstract
 */
var  /**
 * @abstract
 */
AbstractLazyObject3D = /** @class */ (function (_super) {
    __extends(AbstractLazyObject3D, _super);
    function AbstractLazyObject3D() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        /**
         * Flag to signal whether the parent class instance AbstractObject3D called the
         * overwritten method {\@link AbstractModelLoader#afterInit} yet.
         *
         * Unless that method was called, no methods and properties of {\@link AbstractObject3D}
         * may be safely accessed, especially {\@link AbstractObject3D#addChild} and
         * {\@link AbstractObject3D.renderer}.
         */
        _this.parentInitialized = false;
        return _this;
    }
    /**
     * @protected
     * @return {?}
     */
    AbstractLazyObject3D.prototype.afterInit = /**
     * @protected
     * @return {?}
     */
    function () {
        _super.prototype.afterInit.call(this);
        this.parentInitialized = true;
        this.startLoading();
    };
    /**
     * @protected
     * @return {?}
     */
    AbstractLazyObject3D.prototype.startLoading = /**
     * @protected
     * @return {?}
     */
    function () {
        var _this = this;
        // console.log('AbstractLazyObject3D.startLoading');
        // Trigger model acquisition now that the parent has been initialized.
        this.loadLazyObject().then((/**
         * @param {?} obj
         * @return {?}
         */
        function (obj) {
            // console.log('AbstractLazyObject3D loaded');
            // remove old if exists
            if (_this.lazyObject) {
                _super.prototype.removeChild.call(_this, _this.lazyObject);
            }
            // add lazy object to scene
            _this.lazyObject = obj;
            _super.prototype.addChild.call(_this, obj);
            _this.rendererService.render();
        })).catch((/**
         * @param {?} err
         * @return {?}
         */
        function (err) {
            console.error(err);
        }));
    };
    /**
     * @return {?}
     */
    AbstractLazyObject3D.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        if (this.lazyObject) {
            _super.prototype.removeChild.call(this, this.lazyObject);
        }
    };
    /**
     * @protected
     * @return {?}
     */
    AbstractLazyObject3D.prototype.newObject3DInstance = /**
     * @protected
     * @return {?}
     */
    function () {
        // Just empty object (holder of lazy object)
        return new Object3D();
    };
    return AbstractLazyObject3D;
}(AbstractObject3D));
if (false) {
    /**
     * Flag to signal whether the parent class instance AbstractObject3D called the
     * overwritten method {\@link AbstractModelLoader#afterInit} yet.
     *
     * Unless that method was called, no methods and properties of {\@link AbstractObject3D}
     * may be safely accessed, especially {\@link AbstractObject3D#addChild} and
     * {\@link AbstractObject3D.renderer}.
     * @type {?}
     * @private
     */
    AbstractLazyObject3D.prototype.parentInitialized;
    /**
     * This is reference to lazy loaded Object3D (async after init)
     * @type {?}
     * @protected
     */
    AbstractLazyObject3D.prototype.lazyObject;
    /**
     * Abstract method for lazy loading
     *
     * @abstract
     * @protected
     * @return {?}
     */
    AbstractLazyObject3D.prototype.loadLazyObject = function () { };
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Helper parent class for model loader.
 *
 * @see ObjLoaderComponent
 * @abstract
 */
var AbstractModelLoader = /** @class */ (function (_super) {
    __extends(AbstractModelLoader, _super);
    function AbstractModelLoader() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(AbstractModelLoader.prototype, "model", {
        /**
         * The current model data source (usually a URI).
         */
        get: /**
         * The current model data source (usually a URI).
         * @return {?}
         */
        function () {
            return this._model;
        },
        /**
         * The model data source (usually a URI).
         * Settings this property only hides the previous model upon successful
         * loading of the new one. This especially means that if the new data source
         * is invalid, the old model will *not* be removed from the scene.
         */
        set: /**
         * The model data source (usually a URI).
         * Settings this property only hides the previous model upon successful
         * loading of the new one. This especially means that if the new data source
         * is invalid, the old model will *not* be removed from the scene.
         * @param {?} newModelUrl
         * @return {?}
         */
        function (newModelUrl) {
            if (this._model !== newModelUrl) {
                this._model = newModelUrl;
                _super.prototype.startLoading.call(this);
            }
        },
        enumerable: true,
        configurable: true
    });
    AbstractModelLoader.propDecorators = {
        model: [{ type: Input }]
    };
    return AbstractModelLoader;
}(AbstractLazyObject3D));
if (false) {
    /**
     * @type {?}
     * @protected
     */
    AbstractModelLoader.prototype._model;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var ObjectLoaderComponent = /** @class */ (function (_super) {
    __extends(ObjectLoaderComponent, _super);
    function ObjectLoaderComponent(rendererService) {
        var _this = _super.call(this, rendererService) || this;
        _this.rendererService = rendererService;
        _this.loader = new ObjectLoader();
        return _this;
    }
    /**
     * @protected
     * @return {?}
     */
    ObjectLoaderComponent.prototype.loadLazyObject = /**
     * @protected
     * @return {?}
     */
    function () {
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            return __generator(this, function (_a) {
                // console.log('ObjectLoaderComponent.loadLazyObject');
                return [2 /*return*/, new Promise((/**
                     * @param {?} resolve
                     * @param {?} reject
                     * @return {?}
                     */
                    function (resolve, reject) {
                        _this.loader.load(_this.model, (/**
                         * @param {?} model
                         * @return {?}
                         */
                        function (model) {
                            // BUG #95: it seems that some textures loaded after last render (and model has black texture instead)
                            resolve(model);
                        }), undefined, reject);
                    }))];
            });
        });
    };
    ObjectLoaderComponent.decorators = [
        { type: Component, args: [{
                    selector: 'atft-object-loader',
                    providers: [{ provide: AbstractObject3D, useExisting: forwardRef((/**
                             * @return {?}
                             */
                            function () { return ObjectLoaderComponent; })) }],
                    template: '<ng-content></ng-content>'
                }] }
    ];
    /** @nocollapse */
    ObjectLoaderComponent.ctorParameters = function () { return [
        { type: RendererService }
    ]; };
    return ObjectLoaderComponent;
}(AbstractModelLoader));
if (false) {
    /**
     * @type {?}
     * @private
     */
    ObjectLoaderComponent.prototype.loader;
    /**
     * @type {?}
     * @protected
     */
    ObjectLoaderComponent.prototype.rendererService;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Component for employing THREE.OBJLoader to load [Wavefront *.obj files][1].
 *
 * [1]: https://en.wikipedia.org/wiki/Wavefront_.obj_file
 */
var ObjLoaderComponent = /** @class */ (function (_super) {
    __extends(ObjLoaderComponent, _super);
    function ObjLoaderComponent(rendererService) {
        var _this = _super.call(this, rendererService) || this;
        _this.rendererService = rendererService;
        _this.loader = new OBJLoader();
        _this.mtlLoader = new MTLLoader();
        return _this;
    }
    Object.defineProperty(ObjLoaderComponent.prototype, "texturePath", {
        /**
         * Path relative to which resources and textures within the loaded obj file are loaded.
         * @deprecated Rather use resourcePath
         */
        set: /**
         * Path relative to which resources and textures within the loaded obj file are loaded.
         * @deprecated Rather use resourcePath
         * @param {?} newTexturePath
         * @return {?}
         */
        function (newTexturePath) {
            this.resourcePath = newTexturePath;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @protected
     * @return {?}
     */
    ObjLoaderComponent.prototype.loadLazyObject = /**
     * @protected
     * @return {?}
     */
    function () {
        return __awaiter(this, void 0, void 0, function () {
            var preloadingStep;
            var _this = this;
            return __generator(this, function (_a) {
                // Preloading step for the material
                preloadingStep = new Promise((/**
                 * @param {?} resolve
                 * @param {?} reject
                 * @return {?}
                 */
                function (resolve, reject) {
                    if (_this.material === undefined) {
                        // No preloading necessary
                        resolve();
                    }
                    else {
                        // TODO: If typings of mtlLoader are included in the Three.js NPM
                        // package, remove this 'any' cast.
                        ((/** @type {?} */ (_this.mtlLoader))).setResourcePath(_this.resourcePath);
                        _this.mtlLoader.load(_this.material, (/**
                         * @param {?} materialCreator
                         * @return {?}
                         */
                        function (materialCreator) {
                            materialCreator.preload();
                            _this.loader.setMaterials(materialCreator);
                            resolve();
                        }), undefined, reject);
                    }
                }));
                // Await preloading and load final model
                return [2 /*return*/, preloadingStep.then((/**
                     * @return {?}
                     */
                    function () {
                        return new Promise((/**
                         * @param {?} resolve
                         * @param {?} reject
                         * @return {?}
                         */
                        function (resolve, reject) {
                            _this.loader.load(_this.model, (/**
                             * @param {?} model
                             * @return {?}
                             */
                            function (model) {
                                resolve(model);
                            }), undefined, reject);
                        }));
                    }))];
            });
        });
    };
    ObjLoaderComponent.decorators = [
        { type: Component, args: [{
                    selector: 'atft-obj-loader',
                    providers: [{ provide: AbstractObject3D, useExisting: forwardRef((/**
                             * @return {?}
                             */
                            function () { return ObjLoaderComponent; })) }],
                    template: '<ng-content></ng-content>'
                }] }
    ];
    /** @nocollapse */
    ObjLoaderComponent.ctorParameters = function () { return [
        { type: RendererService }
    ]; };
    ObjLoaderComponent.propDecorators = {
        material: [{ type: Input }],
        texturePath: [{ type: Input }],
        resourcePath: [{ type: Input }]
    };
    return ObjLoaderComponent;
}(AbstractModelLoader));
if (false) {
    /**
     * @type {?}
     * @private
     */
    ObjLoaderComponent.prototype.loader;
    /**
     * @type {?}
     * @private
     */
    ObjLoaderComponent.prototype.mtlLoader;
    /** @type {?} */
    ObjLoaderComponent.prototype.material;
    /**
     * Path relative to which resources and textures within the loaded obj file are loaded.
     * @type {?}
     */
    ObjLoaderComponent.prototype.resourcePath;
    /**
     * @type {?}
     * @protected
     */
    ObjLoaderComponent.prototype.rendererService;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var SVGLoaderComponent = /** @class */ (function (_super) {
    __extends(SVGLoaderComponent, _super);
    function SVGLoaderComponent(rendererService) {
        var _this = _super.call(this, rendererService) || this;
        _this.rendererService = rendererService;
        _this._overrideMaterialColor = undefined;
        _this.material = 'basic';
        _this.depthWrite = true;
        _this.centered = true;
        _this.loader = new SVGLoader();
        return _this;
    }
    Object.defineProperty(SVGLoaderComponent.prototype, "overrideMaterialColor", {
        get: /**
         * @return {?}
         */
        function () {
            return this._overrideMaterialColor;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._overrideMaterialColor = value;
            this.startLoading();
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @protected
     * @return {?}
     */
    SVGLoaderComponent.prototype.loadLazyObject = /**
     * @protected
     * @return {?}
     */
    function () {
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            return __generator(this, function (_a) {
                // console.log('ObjectLoaderComponent.loadLazyObject');
                return [2 /*return*/, new Promise((/**
                     * @param {?} resolve
                     * @param {?} reject
                     * @return {?}
                     */
                    function (resolve, reject) {
                        _this.loader.load(_this.model, (/**
                         * @param {?} data
                         * @return {?}
                         */
                        function (data) {
                            /** @type {?} */
                            var paths = data.paths;
                            /** @type {?} */
                            var group = new Group();
                            for (var i = 0; i < paths.length; i++) {
                                // NOTE: It seems that ShapePath does not includes typed color, cast to any as workaround
                                /** @type {?} */
                                var path = paths[i];
                                /** @type {?} */
                                var color = (_this._overrideMaterialColor ? appliedColor(_this._overrideMaterialColor) : path.color);
                                /** @type {?} */
                                var material = appliedMaterial(color, _this.material, _this.depthWrite);
                                /** @type {?} */
                                var shapes = path.toShapes(true, {});
                                for (var j = 0; j < shapes.length; j++) {
                                    /** @type {?} */
                                    var shape = shapes[j];
                                    /** @type {?} */
                                    var geometry = new ShapeBufferGeometry(shape);
                                    /** @type {?} */
                                    var mesh = new Mesh(geometry, material);
                                    group.add(mesh);
                                }
                            }
                            if (_this.maxX || _this.maxY) {
                                scaleToFit(group, new Vector3(_this.maxX, _this.maxY, 0));
                            }
                            if (_this.centered) {
                                fixCenter(group);
                            }
                            resolve(group);
                        }), undefined, reject);
                    }))];
            });
        });
    };
    SVGLoaderComponent.decorators = [
        { type: Component, args: [{
                    selector: 'atft-svg-loader',
                    providers: [{ provide: AbstractObject3D, useExisting: forwardRef((/**
                             * @return {?}
                             */
                            function () { return SVGLoaderComponent; })) }],
                    template: '<ng-content></ng-content>'
                }] }
    ];
    /** @nocollapse */
    SVGLoaderComponent.ctorParameters = function () { return [
        { type: RendererService }
    ]; };
    SVGLoaderComponent.propDecorators = {
        overrideMaterialColor: [{ type: Input }],
        material: [{ type: Input }],
        depthWrite: [{ type: Input }],
        maxX: [{ type: Input }],
        maxY: [{ type: Input }],
        centered: [{ type: Input }]
    };
    return SVGLoaderComponent;
}(AbstractModelLoader));
if (false) {
    /**
     * @type {?}
     * @private
     */
    SVGLoaderComponent.prototype._overrideMaterialColor;
    /** @type {?} */
    SVGLoaderComponent.prototype.material;
    /** @type {?} */
    SVGLoaderComponent.prototype.depthWrite;
    /** @type {?} */
    SVGLoaderComponent.prototype.maxX;
    /** @type {?} */
    SVGLoaderComponent.prototype.maxY;
    /** @type {?} */
    SVGLoaderComponent.prototype.centered;
    /**
     * @type {?}
     * @private
     */
    SVGLoaderComponent.prototype.loader;
    /**
     * @type {?}
     * @protected
     */
    SVGLoaderComponent.prototype.rendererService;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var AtftLoaderModule = /** @class */ (function () {
    function AtftLoaderModule() {
    }
    AtftLoaderModule.decorators = [
        { type: NgModule, args: [{
                    declarations: [
                        ObjLoaderComponent,
                        ObjectLoaderComponent,
                        SVGLoaderComponent
                    ],
                    imports: [
                        CommonModule
                    ],
                    exports: [
                        ObjLoaderComponent,
                        ObjectLoaderComponent,
                        SVGLoaderComponent
                    ]
                },] }
    ];
    return AtftLoaderModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @abstract
 */
var AbstractMesh = /** @class */ (function (_super) {
    __extends(AbstractMesh, _super);
    function AbstractMesh() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.materialColor = 0x5DADE2;
        _this.castShadow = true;
        _this.receiveShadow = true;
        _this.depthWrite = true;
        return _this;
    }
    /**
     * @protected
     * @return {?}
     */
    AbstractMesh.prototype.getMaterial = /**
     * @protected
     * @return {?}
     */
    function () {
        return appliedMaterial(this.materialColor, this.material, this.depthWrite);
    };
    /**
     * @protected
     * @param {?} mesh
     * @return {?}
     */
    AbstractMesh.prototype.applyShadowProps = /**
     * @protected
     * @param {?} mesh
     * @return {?}
     */
    function (mesh) {
        mesh.castShadow = this.castShadow;
        mesh.receiveShadow = this.receiveShadow;
    };
    /**
     * @param {?} changes
     * @return {?}
     */
    AbstractMesh.prototype.ngOnChanges = /**
     * @param {?} changes
     * @return {?}
     */
    function (changes) {
        _super.prototype.ngOnChanges.call(this, changes);
        if (!this.getObject()) {
            return;
        }
        /** @type {?} */
        var mustRerender = false;
        if (['material', 'materialColor', 'depthWrite'].some((/**
         * @param {?} propName
         * @return {?}
         */
        function (propName) { return propName in changes; }))) {
            this.applyMaterial();
            mustRerender = true;
        }
        if (mustRerender) {
            this.rendererService.render();
        }
    };
    /**
     * @return {?}
     */
    AbstractMesh.prototype.applyMaterial = /**
     * @return {?}
     */
    function () {
        this.getObject().material = this.getMaterial();
    };
    AbstractMesh.propDecorators = {
        material: [{ type: Input }],
        materialColor: [{ type: Input }],
        castShadow: [{ type: Input }],
        receiveShadow: [{ type: Input }],
        depthWrite: [{ type: Input }]
    };
    return AbstractMesh;
}(AbstractObject3D));
if (false) {
    /** @type {?} */
    AbstractMesh.prototype.material;
    /** @type {?} */
    AbstractMesh.prototype.materialColor;
    /** @type {?} */
    AbstractMesh.prototype.castShadow;
    /** @type {?} */
    AbstractMesh.prototype.receiveShadow;
    /** @type {?} */
    AbstractMesh.prototype.depthWrite;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var BoxMeshComponent = /** @class */ (function (_super) {
    __extends(BoxMeshComponent, _super);
    function BoxMeshComponent(rendererService) {
        var _this = _super.call(this, rendererService) || this;
        _this.rendererService = rendererService;
        /**
         * Width; that is, the length of the edges parallel to the X axis. Optional; defaults to 1.
         */
        _this.width = 1.0;
        /**
         * Height; that is, the length of the edges parallel to the Y axis. Optional; defaults to 1.
         */
        _this.height = 1.0;
        /**
         * Depth; that is, the length of the edges parallel to the Z axis. Optional; defaults to 1.
         */
        _this.depth = 1.0;
        /**
         * Number of segmented rectangular faces along the width of the sides. Optional; defaults to 1.
         */
        _this.widthSegments = 1;
        /**
         * Number of segmented rectangular faces along the height of the sides. Optional; defaults to 1.
         */
        _this.heightSegments = 1;
        /**
         * Number of segmented rectangular faces along the depth of the sides. Optional; defaults to 1.
         */
        _this.depthSegments = 1;
        return _this;
    }
    /**
     * @protected
     * @return {?}
     */
    BoxMeshComponent.prototype.newObject3DInstance = /**
     * @protected
     * @return {?}
     */
    function () {
        // console.log('BoxMeshComponent.newObject3DInstance');
        /** @type {?} */
        var geometry = new BoxGeometry(this.width, this.height, this.depth, this.widthSegments, this.heightSegments, this.depthSegments);
        /** @type {?} */
        var material = this.getMaterial();
        /** @type {?} */
        var mesh = new Mesh(geometry, material);
        this.applyShadowProps(mesh);
        return mesh;
    };
    BoxMeshComponent.decorators = [
        { type: Component, args: [{
                    selector: 'atft-box-mesh',
                    providers: [{ provide: AbstractObject3D, useExisting: forwardRef((/**
                             * @return {?}
                             */
                            function () { return BoxMeshComponent; })) }],
                    template: '<ng-content></ng-content>'
                }] }
    ];
    /** @nocollapse */
    BoxMeshComponent.ctorParameters = function () { return [
        { type: RendererService }
    ]; };
    BoxMeshComponent.propDecorators = {
        width: [{ type: Input }],
        height: [{ type: Input }],
        depth: [{ type: Input }],
        widthSegments: [{ type: Input }],
        heightSegments: [{ type: Input }],
        depthSegments: [{ type: Input }]
    };
    return BoxMeshComponent;
}(AbstractMesh));
if (false) {
    /**
     * Width; that is, the length of the edges parallel to the X axis. Optional; defaults to 1.
     * @type {?}
     */
    BoxMeshComponent.prototype.width;
    /**
     * Height; that is, the length of the edges parallel to the Y axis. Optional; defaults to 1.
     * @type {?}
     */
    BoxMeshComponent.prototype.height;
    /**
     * Depth; that is, the length of the edges parallel to the Z axis. Optional; defaults to 1.
     * @type {?}
     */
    BoxMeshComponent.prototype.depth;
    /**
     * Number of segmented rectangular faces along the width of the sides. Optional; defaults to 1.
     * @type {?}
     */
    BoxMeshComponent.prototype.widthSegments;
    /**
     * Number of segmented rectangular faces along the height of the sides. Optional; defaults to 1.
     * @type {?}
     */
    BoxMeshComponent.prototype.heightSegments;
    /**
     * Number of segmented rectangular faces along the depth of the sides. Optional; defaults to 1.
     * @type {?}
     */
    BoxMeshComponent.prototype.depthSegments;
    /**
     * @type {?}
     * @protected
     */
    BoxMeshComponent.prototype.rendererService;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var CylinderMeshComponent = /** @class */ (function (_super) {
    __extends(CylinderMeshComponent, _super);
    function CylinderMeshComponent(rendererService) {
        var _this = _super.call(this, rendererService) || this;
        _this.rendererService = rendererService;
        _this.radiusTop = 1.0;
        _this.radiusBottom = 1.0;
        _this.height = 1.0;
        _this.radialSegments = 8;
        _this.heightSegments = 1;
        _this.openEnded = false;
        _this.thetaStart = 0.0;
        _this.thetaLength = 2 * Math.PI;
        return _this;
        // console.log('CylinderMeshComponent.constructor');
    }
    /**
     * @protected
     * @return {?}
     */
    CylinderMeshComponent.prototype.newObject3DInstance = /**
     * @protected
     * @return {?}
     */
    function () {
        // console.log('CylinderMeshComponent.newObject3DInstance');
        /** @type {?} */
        var geometry = new CylinderGeometry(this.radiusTop, this.radiusBottom, this.height, this.radialSegments, this.heightSegments, this.openEnded, this.thetaStart, this.thetaLength);
        /** @type {?} */
        var material = this.getMaterial();
        /** @type {?} */
        var mesh = new Mesh(geometry, material);
        this.applyShadowProps(mesh);
        return mesh;
    };
    CylinderMeshComponent.decorators = [
        { type: Component, args: [{
                    selector: 'atft-cylinder-mesh',
                    providers: [{ provide: AbstractObject3D, useExisting: forwardRef((/**
                             * @return {?}
                             */
                            function () { return CylinderMeshComponent; })) }],
                    template: '<ng-content></ng-content>'
                }] }
    ];
    /** @nocollapse */
    CylinderMeshComponent.ctorParameters = function () { return [
        { type: RendererService }
    ]; };
    CylinderMeshComponent.propDecorators = {
        radiusTop: [{ type: Input }],
        radiusBottom: [{ type: Input }],
        height: [{ type: Input }],
        radialSegments: [{ type: Input }],
        heightSegments: [{ type: Input }],
        openEnded: [{ type: Input }],
        thetaStart: [{ type: Input }],
        thetaLength: [{ type: Input }]
    };
    return CylinderMeshComponent;
}(AbstractMesh));
if (false) {
    /** @type {?} */
    CylinderMeshComponent.prototype.radiusTop;
    /** @type {?} */
    CylinderMeshComponent.prototype.radiusBottom;
    /** @type {?} */
    CylinderMeshComponent.prototype.height;
    /** @type {?} */
    CylinderMeshComponent.prototype.radialSegments;
    /** @type {?} */
    CylinderMeshComponent.prototype.heightSegments;
    /** @type {?} */
    CylinderMeshComponent.prototype.openEnded;
    /** @type {?} */
    CylinderMeshComponent.prototype.thetaStart;
    /** @type {?} */
    CylinderMeshComponent.prototype.thetaLength;
    /**
     * @type {?}
     * @protected
     */
    CylinderMeshComponent.prototype.rendererService;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var FrameMeshComponent = /** @class */ (function (_super) {
    __extends(FrameMeshComponent, _super);
    function FrameMeshComponent(rendererService) {
        var _this = _super.call(this, rendererService) || this;
        _this.rendererService = rendererService;
        _this.thickness = 2;
        _this.sizeX = 20;
        _this.sizeY = 20;
        return _this;
    }
    /**
     * @protected
     * @return {?}
     */
    FrameMeshComponent.prototype.newObject3DInstance = /**
     * @protected
     * @return {?}
     */
    function () {
        /** @type {?} */
        var halfX = this.sizeX / 2.0;
        /** @type {?} */
        var halfY = this.sizeY / 2.0;
        /** @type {?} */
        var t = this.thickness;
        /** @type {?} */
        var shape = new Shape();
        shape.moveTo(-halfX, halfY);
        shape.lineTo(-halfX - t, halfY + t);
        shape.lineTo(halfX + t, halfY + t);
        shape.lineTo(halfX + t, -halfY - t);
        shape.lineTo(-halfX - t, -halfY - t);
        shape.lineTo(-halfX - t, halfY + t);
        shape.lineTo(-halfX, halfY);
        shape.lineTo(-halfX, -halfY);
        shape.lineTo(halfX, -halfY);
        shape.lineTo(halfX, halfY);
        shape.lineTo(-halfX, halfY);
        /** @type {?} */
        var geometry = new ShapeBufferGeometry(shape);
        /** @type {?} */
        var material = this.getMaterial();
        /** @type {?} */
        var mesh = new Mesh(geometry, material);
        this.applyShadowProps(mesh);
        return mesh;
    };
    FrameMeshComponent.decorators = [
        { type: Component, args: [{
                    selector: 'atft-frame-mesh',
                    providers: [{ provide: AbstractObject3D, useExisting: forwardRef((/**
                             * @return {?}
                             */
                            function () { return FrameMeshComponent; })) }],
                    template: '<ng-content></ng-content>'
                }] }
    ];
    /** @nocollapse */
    FrameMeshComponent.ctorParameters = function () { return [
        { type: RendererService }
    ]; };
    FrameMeshComponent.propDecorators = {
        thickness: [{ type: Input }],
        sizeX: [{ type: Input }],
        sizeY: [{ type: Input }]
    };
    return FrameMeshComponent;
}(AbstractMesh));
if (false) {
    /** @type {?} */
    FrameMeshComponent.prototype.thickness;
    /** @type {?} */
    FrameMeshComponent.prototype.sizeX;
    /** @type {?} */
    FrameMeshComponent.prototype.sizeY;
    /**
     * @type {?}
     * @protected
     */
    FrameMeshComponent.prototype.rendererService;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var PlaneMeshComponent = /** @class */ (function (_super) {
    __extends(PlaneMeshComponent, _super);
    function PlaneMeshComponent(rendererService) {
        var _this = _super.call(this, rendererService) || this;
        _this.rendererService = rendererService;
        /**
         * Width; that is, the length of the edges parallel to the X axis. Optional; defaults to 1.
         */
        _this.width = 1.0;
        /**
         * Height; that is, the length of the edges parallel to the Y axis. Optional; defaults to 1.
         */
        _this.height = 1.0;
        /**
         * Number of segmented rectangular faces along the width of the sides. Optional; defaults to 1.
         */
        _this.widthSegments = 1;
        /**
         * Number of segmented rectangular faces along the height of the sides. Optional; defaults to 1.
         */
        _this.heightSegments = 1;
        return _this;
    }
    /**
     * @protected
     * @return {?}
     */
    PlaneMeshComponent.prototype.newObject3DInstance = /**
     * @protected
     * @return {?}
     */
    function () {
        /** @type {?} */
        var geometry = new PlaneBufferGeometry(this.width, this.height, this.widthSegments, this.heightSegments);
        /** @type {?} */
        var material = this.getMaterial();
        /** @type {?} */
        var mesh = new Mesh(geometry, material);
        this.applyShadowProps(mesh);
        return mesh;
    };
    PlaneMeshComponent.decorators = [
        { type: Component, args: [{
                    selector: 'atft-plane-mesh',
                    providers: [{ provide: AbstractObject3D, useExisting: forwardRef((/**
                             * @return {?}
                             */
                            function () { return PlaneMeshComponent; })) }],
                    template: '<ng-content></ng-content>'
                }] }
    ];
    /** @nocollapse */
    PlaneMeshComponent.ctorParameters = function () { return [
        { type: RendererService }
    ]; };
    PlaneMeshComponent.propDecorators = {
        width: [{ type: Input }],
        height: [{ type: Input }],
        widthSegments: [{ type: Input }],
        heightSegments: [{ type: Input }]
    };
    return PlaneMeshComponent;
}(AbstractMesh));
if (false) {
    /**
     * Width; that is, the length of the edges parallel to the X axis. Optional; defaults to 1.
     * @type {?}
     */
    PlaneMeshComponent.prototype.width;
    /**
     * Height; that is, the length of the edges parallel to the Y axis. Optional; defaults to 1.
     * @type {?}
     */
    PlaneMeshComponent.prototype.height;
    /**
     * Number of segmented rectangular faces along the width of the sides. Optional; defaults to 1.
     * @type {?}
     */
    PlaneMeshComponent.prototype.widthSegments;
    /**
     * Number of segmented rectangular faces along the height of the sides. Optional; defaults to 1.
     * @type {?}
     */
    PlaneMeshComponent.prototype.heightSegments;
    /**
     * @type {?}
     * @protected
     */
    PlaneMeshComponent.prototype.rendererService;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var SphereMeshComponent = /** @class */ (function (_super) {
    __extends(SphereMeshComponent, _super);
    function SphereMeshComponent(rendererService) {
        var _this = _super.call(this, rendererService) || this;
        _this.rendererService = rendererService;
        return _this;
    }
    /**
     * @protected
     * @return {?}
     */
    SphereMeshComponent.prototype.newObject3DInstance = /**
     * @protected
     * @return {?}
     */
    function () {
        // console.log('SphereMeshComponent.newObject3DInstance');
        /** @type {?} */
        var geometry = new SphereGeometry(this.radius, this.widthSegments, this.hightSegments);
        /** @type {?} */
        var material = this.getMaterial();
        /** @type {?} */
        var mesh = new Mesh(geometry, material);
        this.applyShadowProps(mesh);
        return mesh;
    };
    SphereMeshComponent.decorators = [
        { type: Component, args: [{
                    selector: 'atft-sphere-mesh',
                    providers: [{ provide: AbstractObject3D, useExisting: forwardRef((/**
                             * @return {?}
                             */
                            function () { return SphereMeshComponent; })) }],
                    template: '<ng-content></ng-content>'
                }] }
    ];
    /** @nocollapse */
    SphereMeshComponent.ctorParameters = function () { return [
        { type: RendererService }
    ]; };
    SphereMeshComponent.propDecorators = {
        radius: [{ type: Input }],
        widthSegments: [{ type: Input }],
        hightSegments: [{ type: Input }]
    };
    return SphereMeshComponent;
}(AbstractMesh));
if (false) {
    /** @type {?} */
    SphereMeshComponent.prototype.radius;
    /** @type {?} */
    SphereMeshComponent.prototype.widthSegments;
    /** @type {?} */
    SphereMeshComponent.prototype.hightSegments;
    /**
     * @type {?}
     * @protected
     */
    SphereMeshComponent.prototype.rendererService;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var TorusMeshComponent = /** @class */ (function (_super) {
    __extends(TorusMeshComponent, _super);
    function TorusMeshComponent(rendererService) {
        var _this = _super.call(this, rendererService) || this;
        _this.rendererService = rendererService;
        /**
         * Radius of the torus, from the center of the torus to the center of the tube
         */
        _this.radius = 0.4;
        _this.radialSegments = 8;
        _this.tubularSegments = 6;
        _this.arc = Math.PI * 2;
        return _this;
    }
    /**
     * @protected
     * @return {?}
     */
    TorusMeshComponent.prototype.newObject3DInstance = /**
     * @protected
     * @return {?}
     */
    function () {
        this.radius *= 1;
        this.tube *= 1;
        this.radialSegments *= 1;
        this.tubularSegments *= 1;
        /** @type {?} */
        var geometry = new TorusGeometry(this.radius, this.tube, this.radialSegments, this.tubularSegments);
        /** @type {?} */
        var material = this.getMaterial();
        /** @type {?} */
        var mesh = new Mesh(geometry, material);
        this.applyShadowProps(mesh);
        return mesh;
    };
    TorusMeshComponent.decorators = [
        { type: Component, args: [{
                    selector: 'atft-torus-mesh',
                    providers: [{ provide: AbstractObject3D, useExisting: forwardRef((/**
                             * @return {?}
                             */
                            function () { return TorusMeshComponent; })) }],
                    template: '<ng-content></ng-content>'
                }] }
    ];
    /** @nocollapse */
    TorusMeshComponent.ctorParameters = function () { return [
        { type: RendererService }
    ]; };
    TorusMeshComponent.propDecorators = {
        radius: [{ type: Input }],
        tube: [{ type: Input }],
        radialSegments: [{ type: Input }],
        tubularSegments: [{ type: Input }],
        arc: [{ type: Input }]
    };
    return TorusMeshComponent;
}(AbstractMesh));
if (false) {
    /**
     * Radius of the torus, from the center of the torus to the center of the tube
     * @type {?}
     */
    TorusMeshComponent.prototype.radius;
    /**
     * Radius of the tube.
     * @type {?}
     */
    TorusMeshComponent.prototype.tube;
    /** @type {?} */
    TorusMeshComponent.prototype.radialSegments;
    /** @type {?} */
    TorusMeshComponent.prototype.tubularSegments;
    /** @type {?} */
    TorusMeshComponent.prototype.arc;
    /**
     * @type {?}
     * @protected
     */
    TorusMeshComponent.prototype.rendererService;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @abstract
 */
var AbstractCss3dMesh = /** @class */ (function (_super) {
    __extends(AbstractCss3dMesh, _super);
    function AbstractCss3dMesh() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.width = 1.0;
        _this.height = 1.0;
        // 1280 / 720 = 1.777777778
        _this.resolutionX = 1280;
        _this.resolutionY = 720;
        _this.widthSegments = 1;
        _this.heightSegments = 1;
        return _this;
    }
    /**
     * @protected
     * @return {?}
     */
    AbstractCss3dMesh.prototype.newObject3DInstance = /**
     * @protected
     * @return {?}
     */
    function () {
        /** @type {?} */
        var geometry = new PlaneBufferGeometry(this.width, this.height, this.widthSegments, this.heightSegments);
        /** @type {?} */
        var material = this.getMaterial();
        /** @type {?} */
        var mesh = new Mesh(geometry, material);
        this.applyShadowProps(mesh);
        // Create and scale css3d object:
        /** @type {?} */
        var meshSize = calculateSize(mesh);
        /** @type {?} */
        var css3dObject = this.createCss3dObject();
        this.scaleCss3d(css3dObject, meshSize);
        // append to mesh:
        mesh.add(css3dObject);
        return mesh;
    };
    /**
     * @protected
     * @param {?} group
     * @param {?} max
     * @return {?}
     */
    AbstractCss3dMesh.prototype.scaleCss3d = /**
     * @protected
     * @param {?} group
     * @param {?} max
     * @return {?}
     */
    function (group, max) {
        /** @type {?} */
        var box = new Vector3(this.resolutionX, this.resolutionY, 0);
        /** @type {?} */
        var scaleX = max.x / box.x;
        /** @type {?} */
        var scaleY = max.y / box.y;
        /** @type {?} */
        var scaleZ = max.z / box.z;
        group.scale.set((scaleX < 1 ? scaleX : 1), (scaleY < 1 ? scaleY : 1), (scaleZ < 1 ? scaleZ : 1));
    };
    /**
     * @protected
     * @return {?}
     */
    AbstractCss3dMesh.prototype.getMaterial = /**
     * @protected
     * @return {?}
     */
    function () {
        // TODO: Renderer clear color
        /** @type {?} */
        var transparentMaterial = new MeshBasicMaterial({
            color: 0x000000,
            opacity: 0,
            side: DoubleSide
        });
        return transparentMaterial;
    };
    AbstractCss3dMesh.propDecorators = {
        width: [{ type: Input }],
        height: [{ type: Input }],
        resolutionX: [{ type: Input }],
        resolutionY: [{ type: Input }]
    };
    return AbstractCss3dMesh;
}(AbstractMesh));
if (false) {
    /** @type {?} */
    AbstractCss3dMesh.prototype.width;
    /** @type {?} */
    AbstractCss3dMesh.prototype.height;
    /** @type {?} */
    AbstractCss3dMesh.prototype.resolutionX;
    /** @type {?} */
    AbstractCss3dMesh.prototype.resolutionY;
    /**
     * @type {?}
     * @private
     */
    AbstractCss3dMesh.prototype.widthSegments;
    /**
     * @type {?}
     * @private
     */
    AbstractCss3dMesh.prototype.heightSegments;
    /**
     * @abstract
     * @protected
     * @return {?}
     */
    AbstractCss3dMesh.prototype.createCss3dObject = function () { };
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var Css3dVideoMeshComponent = /** @class */ (function (_super) {
    __extends(Css3dVideoMeshComponent, _super);
    function Css3dVideoMeshComponent(rendererService) {
        var _this = _super.call(this, rendererService) || this;
        _this.rendererService = rendererService;
        _this.video = document.createElement('video');
        return _this;
    }
    /**
     * @protected
     * @return {?}
     */
    Css3dVideoMeshComponent.prototype.createCss3dObject = /**
     * @protected
     * @return {?}
     */
    function () {
        // 1. Create DIV
        /** @type {?} */
        var div = document.createElement('div');
        div.style.width = this.resolutionX + 'px';
        div.style.height = this.resolutionY + 'px';
        div.style.backgroundColor = '#000000';
        div.id = 'myWrapper';
        // 2. Create Video Player with source
        this.video.autoplay = false;
        this.video.loop = true;
        this.video.muted = true;
        /** @type {?} */
        var source = document.createElement('source');
        source.src = this.videoSrc;
        source.type = 'video/mp4';
        this.video.appendChild(source);
        div.appendChild(this.video);
        // 3. Create CSS3DObject
        /** @type {?} */
        var object = new CSS3DObject(div);
        return object;
    };
    /**
     * @return {?}
     */
    Css3dVideoMeshComponent.prototype.ngAfterViewInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        _super.prototype.ngAfterViewInit.call(this);
        this.video.load();
        this.video.addEventListener('canplay', (/**
         * @return {?}
         */
        function () {
            console.log('EVENT');
            _this.video.play();
        }));
    };
    Css3dVideoMeshComponent.decorators = [
        { type: Component, args: [{
                    selector: 'atft-css3d-video-mesh',
                    providers: [{ provide: AbstractObject3D, useExisting: forwardRef((/**
                             * @return {?}
                             */
                            function () { return Css3dVideoMeshComponent; })) }],
                    template: '<ng-content></ng-content>'
                }] }
    ];
    /** @nocollapse */
    Css3dVideoMeshComponent.ctorParameters = function () { return [
        { type: RendererService }
    ]; };
    Css3dVideoMeshComponent.propDecorators = {
        videoSrc: [{ type: Input }]
    };
    return Css3dVideoMeshComponent;
}(AbstractCss3dMesh));
if (false) {
    /** @type {?} */
    Css3dVideoMeshComponent.prototype.videoSrc;
    /** @type {?} */
    Css3dVideoMeshComponent.prototype.video;
    /**
     * @type {?}
     * @protected
     */
    Css3dVideoMeshComponent.prototype.rendererService;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var AtftMeshModule = /** @class */ (function () {
    function AtftMeshModule() {
    }
    AtftMeshModule.decorators = [
        { type: NgModule, args: [{
                    declarations: [
                        BoxMeshComponent,
                        CylinderMeshComponent,
                        FrameMeshComponent,
                        PlaneMeshComponent,
                        SphereMeshComponent,
                        TorusMeshComponent,
                        Css3dVideoMeshComponent
                    ],
                    imports: [
                        CommonModule
                    ],
                    exports: [
                        BoxMeshComponent,
                        CylinderMeshComponent,
                        FrameMeshComponent,
                        PlaneMeshComponent,
                        SphereMeshComponent,
                        TorusMeshComponent,
                        Css3dVideoMeshComponent
                    ]
                },] }
    ];
    return AtftMeshModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var TextMeshComponent = /** @class */ (function (_super) {
    __extends(TextMeshComponent, _super);
    function TextMeshComponent(rendererService) {
        var _this = _super.call(this, rendererService) || this;
        _this.rendererService = rendererService;
        _this.material = 'basic';
        _this._materialColor = 0xDADADA;
        _this._text = 'Text';
        _this.size = 10;
        _this.height = 0.3;
        _this.curveSegments = 2;
        _this.bevelEnabled = false;
        _this.bevelThickness = 0.1;
        _this.bevelSize = 0.1;
        _this.bevelOffset = 0;
        _this.bevelSegments = 1;
        _this.fontUrl = './assets/font/helvetiker_regular.typeface.json';
        _this.castShadow = true;
        _this.receiveShadow = true;
        _this.depthWrite = true;
        _this.centered = true;
        return _this;
    }
    Object.defineProperty(TextMeshComponent.prototype, "materialColor", {
        get: /**
         * @return {?}
         */
        function () {
            return this._materialColor;
        },
        set: /**
         * @param {?} materialColor
         * @return {?}
         */
        function (materialColor) {
            // console.log('change color', materialColor);
            this._materialColor = materialColor;
            this.startLoading();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TextMeshComponent.prototype, "text", {
        get: /**
         * @return {?}
         */
        function () {
            return this._text;
        },
        set: /**
         * @param {?} text
         * @return {?}
         */
        function (text) {
            this._text = text;
            this.startLoading();
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    TextMeshComponent.prototype.getMaterial = /**
     * @return {?}
     */
    function () {
        return appliedMaterial(this.materialColor, this.material, this.depthWrite);
    };
    /**
     * @protected
     * @return {?}
     */
    TextMeshComponent.prototype.loadLazyObject = /**
     * @protected
     * @return {?}
     */
    function () {
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            return __generator(this, function (_a) {
                // console.log('TextMeshComponent.loadLazyObject');
                return [2 /*return*/, new Promise((/**
                     * @param {?} resolve
                     * @return {?}
                     */
                    function (resolve) {
                        /** @type {?} */
                        var loader = new FontLoader();
                        loader.load(_this.fontUrl, (/**
                         * @param {?} font
                         * @return {?}
                         */
                        function (font) {
                            /** @type {?} */
                            var geometry = new TextGeometry(_this.text, {
                                font: font,
                                size: _this.size,
                                height: _this.height,
                                curveSegments: _this.curveSegments,
                                bevelEnabled: _this.bevelEnabled,
                                bevelThickness: _this.bevelThickness,
                                bevelSize: _this.bevelSize,
                                bevelOffset: _this.bevelOffset,
                                bevelSegments: _this.bevelOffset
                            });
                            /** @type {?} */
                            var material = _this.getMaterial();
                            /** @type {?} */
                            var mesh = new Mesh(geometry, material);
                            mesh.castShadow = _this.castShadow;
                            mesh.receiveShadow = _this.receiveShadow;
                            if (_this.centered) {
                                fixCenter(mesh);
                            }
                            resolve(mesh);
                        }));
                    }))];
            });
        });
    };
    TextMeshComponent.decorators = [
        { type: Component, args: [{
                    selector: 'atft-text-mesh',
                    providers: [{ provide: AbstractObject3D, useExisting: forwardRef((/**
                             * @return {?}
                             */
                            function () { return TextMeshComponent; })) }],
                    template: '<ng-content></ng-content>'
                }] }
    ];
    /** @nocollapse */
    TextMeshComponent.ctorParameters = function () { return [
        { type: RendererService }
    ]; };
    TextMeshComponent.propDecorators = {
        material: [{ type: Input }],
        materialColor: [{ type: Input }],
        text: [{ type: Input }],
        size: [{ type: Input }],
        height: [{ type: Input }],
        curveSegments: [{ type: Input }],
        bevelEnabled: [{ type: Input }],
        bevelThickness: [{ type: Input }],
        bevelSize: [{ type: Input }],
        bevelOffset: [{ type: Input }],
        bevelSegments: [{ type: Input }],
        fontUrl: [{ type: Input }],
        castShadow: [{ type: Input }],
        receiveShadow: [{ type: Input }],
        depthWrite: [{ type: Input }],
        centered: [{ type: Input }]
    };
    return TextMeshComponent;
}(AbstractLazyObject3D));
if (false) {
    /** @type {?} */
    TextMeshComponent.prototype.material;
    /**
     * @type {?}
     * @private
     */
    TextMeshComponent.prototype._materialColor;
    /**
     * @type {?}
     * @private
     */
    TextMeshComponent.prototype._text;
    /** @type {?} */
    TextMeshComponent.prototype.size;
    /** @type {?} */
    TextMeshComponent.prototype.height;
    /** @type {?} */
    TextMeshComponent.prototype.curveSegments;
    /** @type {?} */
    TextMeshComponent.prototype.bevelEnabled;
    /** @type {?} */
    TextMeshComponent.prototype.bevelThickness;
    /** @type {?} */
    TextMeshComponent.prototype.bevelSize;
    /** @type {?} */
    TextMeshComponent.prototype.bevelOffset;
    /** @type {?} */
    TextMeshComponent.prototype.bevelSegments;
    /** @type {?} */
    TextMeshComponent.prototype.fontUrl;
    /** @type {?} */
    TextMeshComponent.prototype.castShadow;
    /** @type {?} */
    TextMeshComponent.prototype.receiveShadow;
    /** @type {?} */
    TextMeshComponent.prototype.depthWrite;
    /** @type {?} */
    TextMeshComponent.prototype.centered;
    /**
     * @type {?}
     * @protected
     */
    TextMeshComponent.prototype.rendererService;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var AtftTextModule = /** @class */ (function () {
    function AtftTextModule() {
    }
    AtftTextModule.decorators = [
        { type: NgModule, args: [{
                    declarations: [
                        TextMeshComponent
                    ],
                    imports: [
                        CommonModule
                    ],
                    exports: [
                        TextMeshComponent
                    ]
                },] }
    ];
    return AtftTextModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var SceneComponent = /** @class */ (function (_super) {
    __extends(SceneComponent, _super);
    function SceneComponent(rendererService) {
        var _this = _super.call(this, rendererService) || this;
        _this.rendererService = rendererService;
        _this.background = 0xffffff;
        _this.fog = false;
        _this.fogColor = 0xa0a0a0;
        _this.fogNear = 10;
        _this.fogFar = 500;
        // TODO: directive?
        rendererService.setScene(_this);
        return _this;
    }
    /**
     * @protected
     * @return {?}
     */
    SceneComponent.prototype.newObject3DInstance = /**
     * @protected
     * @return {?}
     */
    function () {
        /** @type {?} */
        var scene = new Scene();
        scene.background = new Color(appliedColor(this.background));
        if (this.fog === true) {
            scene.fog = new Fog(appliedColor(this.fogColor), this.fogNear, this.fogFar);
        }
        return scene;
    };
    SceneComponent.decorators = [
        { type: Component, args: [{
                    selector: 'atft-scene',
                    providers: [{ provide: AbstractObject3D, useExisting: forwardRef((/**
                             * @return {?}
                             */
                            function () { return SceneComponent; })) }],
                    template: '<ng-content></ng-content>'
                }] }
    ];
    /** @nocollapse */
    SceneComponent.ctorParameters = function () { return [
        { type: RendererService }
    ]; };
    SceneComponent.propDecorators = {
        background: [{ type: Input }],
        fog: [{ type: Input }],
        fogColor: [{ type: Input }],
        fogNear: [{ type: Input }],
        fogFar: [{ type: Input }]
    };
    return SceneComponent;
}(AbstractObject3D));
if (false) {
    /** @type {?} */
    SceneComponent.prototype.background;
    /** @type {?} */
    SceneComponent.prototype.fog;
    /** @type {?} */
    SceneComponent.prototype.fogColor;
    /** @type {?} */
    SceneComponent.prototype.fogNear;
    /** @type {?} */
    SceneComponent.prototype.fogFar;
    /**
     * @type {?}
     * @protected
     */
    SceneComponent.prototype.rendererService;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var AtftObjectModule = /** @class */ (function () {
    function AtftObjectModule() {
    }
    AtftObjectModule.decorators = [
        { type: NgModule, args: [{
                    imports: [
                        CommonModule,
                        AtftConnectorModule,
                        AtftHelperModule,
                        AtftLightModule,
                        AtftLoaderModule,
                        AtftMeshModule,
                        AtftTextModule
                    ],
                    declarations: [
                        SceneComponent
                    ],
                    exports: [
                        SceneComponent,
                        CommonModule,
                        AtftConnectorModule,
                        AtftHelperModule,
                        AtftLightModule,
                        AtftLoaderModule,
                        AtftMeshModule,
                        AtftTextModule
                    ]
                },] }
    ];
    return AtftObjectModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var RaycasterService = /** @class */ (function () {
    function RaycasterService() {
        this.raycaster = new Raycaster();
        this.enabled = false;
        this.groups = [];
        this.paused = false;
        this.onMouseMove = this.onMouseMove.bind(this);
        this.onMouseDown = this.onMouseDown.bind(this);
        this.onTouchStart = this.onTouchStart.bind(this);
        this.subscribe();
    }
    /**
     * @return {?}
     */
    RaycasterService.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.disable();
        this.unsubscribe();
    };
    /**
     * @private
     * @return {?}
     */
    RaycasterService.prototype.subscribe = /**
     * @private
     * @return {?}
     */
    function () {
        window.addEventListener('mousemove', this.onMouseMove);
        window.addEventListener('mousedown', this.onMouseDown);
        window.addEventListener('touchstart', this.onTouchStart);
    };
    /**
     * @private
     * @return {?}
     */
    RaycasterService.prototype.unsubscribe = /**
     * @private
     * @return {?}
     */
    function () {
        // console.log('unsubscribe raycaster');
        window.removeEventListener('mousemove', this.onMouseMove);
        window.removeEventListener('mousedown', this.onMouseDown);
        window.removeEventListener('touchstart', this.onTouchStart);
    };
    /**
     * @return {?}
     */
    RaycasterService.prototype.enable = /**
     * @return {?}
     */
    function () {
        this.enabled = true;
    };
    /**
     * @return {?}
     */
    RaycasterService.prototype.disable = /**
     * @return {?}
     */
    function () {
        this.enabled = false;
    };
    /**
     * @return {?}
     */
    RaycasterService.prototype.pause = /**
     * @return {?}
     */
    function () {
        this.paused = true;
    };
    /**
     * @return {?}
     */
    RaycasterService.prototype.resume = /**
     * @return {?}
     */
    function () {
        this.paused = false;
    };
    Object.defineProperty(RaycasterService.prototype, "isEnabled", {
        get: /**
         * @return {?}
         */
        function () {
            return this.enabled;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} camera
     * @return {?}
     */
    RaycasterService.prototype.setCamera = /**
     * @param {?} camera
     * @return {?}
     */
    function (camera) {
        // console.log('Add camera to raycaster', camera);
        this.camera = camera;
    };
    /**
     * @param {?} group
     * @return {?}
     */
    RaycasterService.prototype.addGroup = /**
     * @param {?} group
     * @return {?}
     */
    function (group) {
        // console.log('RaycasterService.addGroup', group.name, group);
        this.groups.push(group);
    };
    /**
     * @private
     * @param {?} event
     * @return {?}
     */
    RaycasterService.prototype.onMouseMove = /**
     * @private
     * @param {?} event
     * @return {?}
     */
    function (event) {
        if (!this.isReady()) {
            return;
        }
        event.preventDefault();
        /** @type {?} */
        var i = this.getFirstIntersectedGroup(event.layerX, event.layerY);
        if (!this.selected || this.selected !== i) {
            if (this.selected) {
                this.selected.dispatchEvent({ type: 'mouseExit' });
                this.selected = null;
            }
            if (i) {
                this.selected = i;
                // console.log('RaycasterService.mouseEnter', i);
                this.selected.dispatchEvent({ type: 'mouseEnter' });
            }
        }
    };
    /**
     * @private
     * @param {?} event
     * @return {?}
     */
    RaycasterService.prototype.onMouseDown = /**
     * @private
     * @param {?} event
     * @return {?}
     */
    function (event) {
        if (!this.isReady(true)) {
            return;
        }
        event.preventDefault();
        /** @type {?} */
        var i = this.getFirstIntersectedGroup(event.layerX, event.layerY);
        if (i) {
            i.dispatchEvent({ type: 'mouseDown' });
        }
    };
    /**
     * @private
     * @param {?} event
     * @return {?}
     */
    RaycasterService.prototype.onTouchStart = /**
     * @private
     * @param {?} event
     * @return {?}
     */
    function (event) {
        // console.log(event);
        if (!this.isReady()) {
            return;
        }
        event.preventDefault();
        /** @type {?} */
        var i = this.getFirstIntersectedGroup(event.touches[0].clientX, event.touches[0].clientY);
        if (i) {
            i.dispatchEvent({ type: 'mouseDown' });
        }
    };
    /**
     * @private
     * @param {?=} ignorePaused
     * @return {?}
     */
    RaycasterService.prototype.isReady = /**
     * @private
     * @param {?=} ignorePaused
     * @return {?}
     */
    function (ignorePaused) {
        return this.enabled
            && (ignorePaused || !this.paused)
            && this.camera
            && this.camera.camera
            && this.groups
            && this.groups.length > 0;
    };
    /**
     * @private
     * @param {?} x
     * @param {?} y
     * @return {?}
     */
    RaycasterService.prototype.getFirstIntersectedGroup = /**
     * @private
     * @param {?} x
     * @param {?} y
     * @return {?}
     */
    function (x, y) {
        x = (x / window.innerWidth) * 2 - 1;
        y = -(y / window.innerHeight) * 2 + 1;
        /** @type {?} */
        var mouseVector = new Vector3(x, y, 0.5);
        this.raycaster.setFromCamera(mouseVector, this.camera.camera);
        // loop across all groups. Try to find the group with nearest distance.
        /** @type {?} */
        var nearestIntersection;
        /** @type {?} */
        var nearestGroup;
        for (var k = 0; k < this.groups.length; k++) {
            /** @type {?} */
            var i = this.groups[k].getObject();
            /** @type {?} */
            var intersection = this.raycaster.intersectObject(i, true);
            if (intersection.length > 0 && (!nearestIntersection || nearestIntersection.distance > intersection[0].distance)) {
                nearestIntersection = intersection[0];
                nearestGroup = i;
            }
        }
        // return the group with nearest distance
        if (nearestGroup) {
            return nearestGroup;
        }
        else {
            return;
        }
    };
    RaycasterService.decorators = [
        { type: Injectable }
    ];
    /** @nocollapse */
    RaycasterService.ctorParameters = function () { return []; };
    return RaycasterService;
}());
if (false) {
    /**
     * @type {?}
     * @private
     */
    RaycasterService.prototype.raycaster;
    /**
     * @type {?}
     * @private
     */
    RaycasterService.prototype.selected;
    /**
     * @type {?}
     * @private
     */
    RaycasterService.prototype.enabled;
    /**
     * @type {?}
     * @private
     */
    RaycasterService.prototype.camera;
    /**
     * @type {?}
     * @private
     */
    RaycasterService.prototype.groups;
    /**
     * @type {?}
     * @private
     */
    RaycasterService.prototype.paused;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var RendererCanvasComponent = /** @class */ (function () {
    function RendererCanvasComponent(rendererService) {
        this.rendererService = rendererService;
        // console.log('RendererComponent.constructor');
        this.onResize = this.onResize.bind(this);
    }
    /**
     * @return {?}
     */
    RendererCanvasComponent.prototype.ngAfterViewInit = /**
     * @return {?}
     */
    function () {
        // console.log('RendererComponent.ngAfterViewInit');
        this.rendererService.initialize(this.canvas);
    };
    Object.defineProperty(RendererCanvasComponent.prototype, "renderPane", {
        /**
         * The render pane on which the scene is rendered.
         * Currently, only the WebGL renderer with a canvas is used in this
         * implementation, so this property will always be an ElementRef to the
         * underlying <canvas> element.
         *
         * @example This property can be used to restrict the orbit control (i.e. the
         * area which is listened for mouse move and zoom events) to the rendering pane
         */
        get: /**
         * The render pane on which the scene is rendered.
         * Currently, only the WebGL renderer with a canvas is used in this
         * implementation, so this property will always be an ElementRef to the
         * underlying <canvas> element.
         *
         * \@example This property can be used to restrict the orbit control (i.e. the
         * area which is listened for mouse move and zoom events) to the rendering pane
         * @return {?}
         */
        function () {
            return this.canvasRef;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RendererCanvasComponent.prototype, "canvas", {
        get: /**
         * @private
         * @return {?}
         */
        function () {
            return this.canvasRef.nativeElement;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} event
     * @return {?}
     */
    RendererCanvasComponent.prototype.onResize = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        // strange, but single 100% resizing has unexpected behaviour with flex CSS
        // as workaround - resettling to 100 pixels, then to 100%
        this.rendererService.resize(this.canvas, '100px');
        this.rendererService.resize(this.canvas, '100%');
    };
    RendererCanvasComponent.decorators = [
        { type: Component, args: [{
                    selector: 'atft-renderer-canvas',
                    template: "<canvas #canvas>\r\n  <ng-content></ng-content>\r\n</canvas>\r\n",
                    styles: [":host{display:flex;flex:1}canvas{flex:1}"]
                }] }
    ];
    /** @nocollapse */
    RendererCanvasComponent.ctorParameters = function () { return [
        { type: RendererService }
    ]; };
    RendererCanvasComponent.propDecorators = {
        canvasRef: [{ type: ViewChild, args: ['canvas', { static: true },] }],
        onResize: [{ type: HostListener, args: ['window:resize', ['$event'],] }]
    };
    return RendererCanvasComponent;
}());
if (false) {
    /**
     * @type {?}
     * @private
     */
    RendererCanvasComponent.prototype.canvasRef;
    /**
     * @type {?}
     * @private
     */
    RendererCanvasComponent.prototype.rendererService;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @abstract
 * @template T
 */
var AbstractOrbitControls = /** @class */ (function () {
    function AbstractOrbitControls(rendererService, raycasterService) {
        this.rendererService = rendererService;
        this.raycasterService = raycasterService;
        // console.log('OrbitControlsComponent.constructor');
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    AbstractOrbitControls.prototype.ngOnChanges = /**
     * @param {?} changes
     * @return {?}
     */
    function (changes) {
        // If the THREE.js OrbitControls are not set up yet, we do not need to update
        // anything as they will pick the new values from the @Input properties automatically
        // upon creation.
        if (!this.controls) {
            return;
        }
        if (changes['listeningControlElement']) {
            // The DOM element the OrbitControls listen on cannot be changed once an
            // OrbitControls object is created. We thus need to recreate it.
            this.controls.dispose();
            this.setUpControls();
        }
    };
    /**
     * @return {?}
     */
    AbstractOrbitControls.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        if (this.controls) {
            this.controls.dispose();
        }
    };
    /**
     * @private
     * @return {?}
     */
    AbstractOrbitControls.prototype.configureListeners = /**
     * @private
     * @return {?}
     */
    function () {
        var _this = this;
        this.controls.addEventListener('change', (/**
         * @return {?}
         */
        function () {
            _this.rendererService.render();
        }));
        // don't raycast during rotation/damping/panning
        if (this.raycasterService.isEnabled) {
            this.controls.addEventListener('start', (/**
             * @return {?}
             */
            function () {
                _this.raycasterService.pause();
            }));
            this.controls.addEventListener('end', (/**
             * @return {?}
             */
            function () {
                _this.raycasterService.resume();
            }));
        }
    };
    /**
     * @return {?}
     */
    AbstractOrbitControls.prototype.ngAfterViewInit = /**
     * @return {?}
     */
    function () {
        // console.log('OrbitControlsComponent.ngAfterViewInit');
        if (this.childCameras === undefined || this.childCameras.first === undefined) {
            throw new Error('Camera is not found');
        }
        if (!this.webGlRenderer) {
            throw new Error('webGlRenderer is not found');
        }
        this.listeningControlElement = this.webGlRenderer.renderPane;
        this.setUpControls();
        this.configureListeners();
        this.rendererService.render();
    };
    AbstractOrbitControls.propDecorators = {
        childCameras: [{ type: ContentChildren, args: [AbstractCamera, { descendants: true },] }],
        webGlRenderer: [{ type: ContentChild, args: [RendererCanvasComponent, { static: false },] }]
    };
    return AbstractOrbitControls;
}());
if (false) {
    /** @type {?} */
    AbstractOrbitControls.prototype.childCameras;
    /** @type {?} */
    AbstractOrbitControls.prototype.webGlRenderer;
    /**
     * The element on whose native element the orbit control will listen for mouse events.
     *
     * Note that keyboard events are still listened for on the global window object, this is
     * a known issue from Three.js: https://github.com/mrdoob/three.js/pull/10315
     * @type {?}
     * @protected
     */
    AbstractOrbitControls.prototype.listeningControlElement;
    /**
     * @type {?}
     * @protected
     */
    AbstractOrbitControls.prototype.controls;
    /**
     * @type {?}
     * @protected
     */
    AbstractOrbitControls.prototype.rendererService;
    /**
     * @type {?}
     * @protected
     */
    AbstractOrbitControls.prototype.raycasterService;
    /**
     * @abstract
     * @protected
     * @return {?}
     */
    AbstractOrbitControls.prototype.setUpControls = function () { };
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var OrbitControlsComponent = /** @class */ (function (_super) {
    __extends(OrbitControlsComponent, _super);
    function OrbitControlsComponent(rendererService, raycasterService) {
        var _this = _super.call(this, rendererService, raycasterService) || this;
        _this.rendererService = rendererService;
        _this.raycasterService = raycasterService;
        _this.rotateSpeed = 1.0;
        _this.zoomSpeed = 1.2;
        return _this;
    }
    /**
     * @protected
     * @return {?}
     */
    OrbitControlsComponent.prototype.setUpControls = /**
     * @protected
     * @return {?}
     */
    function () {
        this.controls = new OrbitControls(this.childCameras.first.camera, this.listeningControlElement && this.listeningControlElement.nativeElement);
        this.controls.rotateSpeed = this.rotateSpeed;
        this.controls.zoomSpeed = this.zoomSpeed;
    };
    /**
     * @param {?} changes
     * @return {?}
     */
    OrbitControlsComponent.prototype.ngOnChanges = /**
     * @param {?} changes
     * @return {?}
     */
    function (changes) {
        if (!this.controls) {
            return;
        }
        _super.prototype.ngOnChanges.call(this, changes);
        if (changes['rotateSpeed']) {
            this.controls.rotateSpeed = this.rotateSpeed;
        }
        if (changes['zoomSpeed']) {
            this.controls.zoomSpeed = this.zoomSpeed;
        }
    };
    OrbitControlsComponent.decorators = [
        { type: Component, args: [{
                    selector: 'atft-orbit-controls',
                    template: "\n      <ng-content></ng-content>",
                    styles: [":host{display:flex;flex:1}"]
                }] }
    ];
    /** @nocollapse */
    OrbitControlsComponent.ctorParameters = function () { return [
        { type: RendererService },
        { type: RaycasterService }
    ]; };
    OrbitControlsComponent.propDecorators = {
        rotateSpeed: [{ type: Input }],
        zoomSpeed: [{ type: Input }]
    };
    return OrbitControlsComponent;
}(AbstractOrbitControls));
if (false) {
    /** @type {?} */
    OrbitControlsComponent.prototype.rotateSpeed;
    /** @type {?} */
    OrbitControlsComponent.prototype.zoomSpeed;
    /**
     * @type {?}
     * @protected
     */
    OrbitControlsComponent.prototype.rendererService;
    /**
     * @type {?}
     * @protected
     */
    OrbitControlsComponent.prototype.raycasterService;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var MapControlsComponent = /** @class */ (function (_super) {
    __extends(MapControlsComponent, _super);
    function MapControlsComponent(rendererService, raycasterService, animationService) {
        var _this = _super.call(this, rendererService, raycasterService) || this;
        _this.rendererService = rendererService;
        _this.raycasterService = raycasterService;
        _this.animationService = animationService;
        _this.rotateSpeed = 1.0;
        _this.zoomSpeed = 1.2;
        _this.autoRotate = false;
        _this.autoRotateSpeed = 0.5;
        _this.enableDamping = false;
        _this.dampingFactor = 0.1;
        _this.screenSpacePanning = false;
        _this.minDistance = 20;
        _this.maxDistance = 200;
        _this.maxPolarAngle = Math.PI / 2 - 0.1;
        _this.panSpeed = 1.2;
        return _this;
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    MapControlsComponent.prototype.ngOnChanges = /**
     * @param {?} changes
     * @return {?}
     */
    function (changes) {
        if (!this.controls) {
            return;
        }
        _super.prototype.ngOnChanges.call(this, changes);
        if (changes['rotateSpeed']) {
            this.controls.rotateSpeed = this.rotateSpeed;
        }
        if (changes['zoomSpeed']) {
            this.controls.zoomSpeed = this.zoomSpeed;
        }
        // TODO: add others
    };
    /**
     * @protected
     * @return {?}
     */
    MapControlsComponent.prototype.setUpControls = /**
     * @protected
     * @return {?}
     */
    function () {
        var _this = this;
        this.controls = new MapControls(this.childCameras.first.camera, this.listeningControlElement && this.listeningControlElement.nativeElement);
        this.controls.rotateSpeed = this.rotateSpeed;
        this.controls.zoomSpeed = this.zoomSpeed;
        this.controls.panSpeed = this.panSpeed;
        this.controls.autoRotate = this.autoRotate;
        this.controls.autoRotateSpeed = this.autoRotateSpeed;
        this.controls.enableDamping = this.enableDamping; // an animation loop is required when either damping or auto-rotation are enabled
        this.controls.dampingFactor = this.dampingFactor;
        this.controls.screenSpacePanning = this.screenSpacePanning;
        this.controls.minDistance = this.minDistance;
        this.controls.maxDistance = this.maxDistance;
        this.controls.maxPolarAngle = this.maxPolarAngle;
        this.controls.update();
        // Advanced animation:
        if (this.autoRotate || this.enableDamping) {
            this.animationService.animate.subscribe((/**
             * @return {?}
             */
            function () {
                _this.controls.update();
            }));
            this.controls.addEventListener('change', (/**
             * @return {?}
             */
            function () {
                _this.rendererService.render();
            }));
            this.animationService.start();
        }
        this.rendererService.render();
    };
    MapControlsComponent.decorators = [
        { type: Component, args: [{
                    selector: 'atft-map-controls',
                    template: "\n      <ng-content></ng-content>",
                    styles: [":host{display:flex;flex:1}"]
                }] }
    ];
    /** @nocollapse */
    MapControlsComponent.ctorParameters = function () { return [
        { type: RendererService },
        { type: RaycasterService },
        { type: AnimationService }
    ]; };
    MapControlsComponent.propDecorators = {
        rotateSpeed: [{ type: Input }],
        zoomSpeed: [{ type: Input }],
        autoRotate: [{ type: Input }],
        autoRotateSpeed: [{ type: Input }],
        enableDamping: [{ type: Input }],
        dampingFactor: [{ type: Input }],
        screenSpacePanning: [{ type: Input }],
        minDistance: [{ type: Input }],
        maxDistance: [{ type: Input }],
        maxPolarAngle: [{ type: Input }],
        panSpeed: [{ type: Input }]
    };
    return MapControlsComponent;
}(AbstractOrbitControls));
if (false) {
    /** @type {?} */
    MapControlsComponent.prototype.rotateSpeed;
    /** @type {?} */
    MapControlsComponent.prototype.zoomSpeed;
    /** @type {?} */
    MapControlsComponent.prototype.autoRotate;
    /** @type {?} */
    MapControlsComponent.prototype.autoRotateSpeed;
    /** @type {?} */
    MapControlsComponent.prototype.enableDamping;
    /** @type {?} */
    MapControlsComponent.prototype.dampingFactor;
    /** @type {?} */
    MapControlsComponent.prototype.screenSpacePanning;
    /** @type {?} */
    MapControlsComponent.prototype.minDistance;
    /** @type {?} */
    MapControlsComponent.prototype.maxDistance;
    /** @type {?} */
    MapControlsComponent.prototype.maxPolarAngle;
    /** @type {?} */
    MapControlsComponent.prototype.panSpeed;
    /**
     * @type {?}
     * @protected
     */
    MapControlsComponent.prototype.rendererService;
    /**
     * @type {?}
     * @protected
     */
    MapControlsComponent.prototype.raycasterService;
    /**
     * @type {?}
     * @protected
     */
    MapControlsComponent.prototype.animationService;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var AtftControlModule = /** @class */ (function () {
    function AtftControlModule() {
    }
    AtftControlModule.decorators = [
        { type: NgModule, args: [{
                    declarations: [
                        OrbitControlsComponent,
                        MapControlsComponent
                    ],
                    imports: [
                        CommonModule
                    ],
                    exports: [
                        OrbitControlsComponent,
                        MapControlsComponent
                    ]
                },] }
    ];
    return AtftControlModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var Deg2RadPipe = /** @class */ (function () {
    function Deg2RadPipe() {
    }
    /**
     * Converts degrees to radians
     * @param degree Degrees
     */
    /**
     * Converts degrees to radians
     * @param {?} degrees
     * @return {?}
     */
    Deg2RadPipe.prototype.transform = /**
     * Converts degrees to radians
     * @param {?} degrees
     * @return {?}
     */
    function (degrees) {
        return (degrees / 180) * Math.PI;
    };
    Deg2RadPipe.decorators = [
        { type: Pipe, args: [{
                    name: 'deg2rad'
                },] }
    ];
    return Deg2RadPipe;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var Rad2DegPipe = /** @class */ (function () {
    function Rad2DegPipe() {
    }
    /**
     * Converts radians to degrees
     * @param radians Radians
     */
    /**
     * Converts radians to degrees
     * @param {?} radians Radians
     * @return {?}
     */
    Rad2DegPipe.prototype.transform = /**
     * Converts radians to degrees
     * @param {?} radians Radians
     * @return {?}
     */
    function (radians) {
        return radians * (180 / Math.PI);
    };
    Rad2DegPipe.decorators = [
        { type: Pipe, args: [{
                    name: 'rad2deg'
                },] }
    ];
    return Rad2DegPipe;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var AtftPipeModule = /** @class */ (function () {
    function AtftPipeModule() {
    }
    AtftPipeModule.decorators = [
        { type: NgModule, args: [{
                    imports: [
                        CommonModule
                    ],
                    declarations: [
                        Deg2RadPipe,
                        Rad2DegPipe
                    ],
                    exports: [
                        Deg2RadPipe,
                        Rad2DegPipe
                    ]
                },] }
    ];
    return AtftPipeModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var AtftRendererModule = /** @class */ (function () {
    function AtftRendererModule() {
    }
    AtftRendererModule.decorators = [
        { type: NgModule, args: [{
                    imports: [
                        CommonModule
                    ],
                    declarations: [
                        RendererCanvasComponent
                    ],
                    providers: [
                        RendererService
                    ],
                    exports: [
                        RendererCanvasComponent
                    ]
                },] }
    ];
    return AtftRendererModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var AtftAnimationModule = /** @class */ (function () {
    function AtftAnimationModule() {
    }
    AtftAnimationModule.decorators = [
        { type: NgModule, args: [{
                    providers: [
                        AnimationService
                    ]
                },] }
    ];
    return AtftAnimationModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Only components marked as atft-raycaster-group emit raycaster events.
 * NOTE: All childs are also considered by raycaster (very usefull, for composite components).
 */
var RaycasterGroupDirective = /** @class */ (function () {
    function RaycasterGroupDirective(host, raycasterService) {
        this.host = host;
        this.raycasterService = raycasterService;
        this.mouseEnter = new EventEmitter();
        this.mouseExit = new EventEmitter();
        this.mouseDown = new EventEmitter();
        this.onMouseEnter = this.onMouseEnter.bind(this);
        this.onMouseExit = this.onMouseExit.bind(this);
        this.onMouseDown = this.onMouseDown.bind(this);
    }
    /**
     * @return {?}
     */
    RaycasterGroupDirective.prototype.ngAfterViewInit = /**
     * @return {?}
     */
    function () {
        this.raycasterService.addGroup(this.host);
        this.subscribeEvents();
    };
    /**
     * @private
     * @return {?}
     */
    RaycasterGroupDirective.prototype.subscribeEvents = /**
     * @private
     * @return {?}
     */
    function () {
        /** @type {?} */
        var obj = this.host.getObject();
        obj.addEventListener('mouseEnter', this.onMouseEnter);
        obj.addEventListener('mouseExit', this.onMouseExit);
        obj.addEventListener('mouseDown', this.onMouseDown);
    };
    /**
     * @private
     * @return {?}
     */
    RaycasterGroupDirective.prototype.unSubscribeEvents = /**
     * @private
     * @return {?}
     */
    function () {
        /** @type {?} */
        var obj = this.host.getObject();
        obj.removeEventListener('mouseEnter', this.onMouseEnter);
        obj.removeEventListener('mouseExit', this.onMouseExit);
        obj.removeEventListener('mouseDown', this.onMouseDown);
    };
    /**
     * @private
     * @return {?}
     */
    RaycasterGroupDirective.prototype.onMouseExit = /**
     * @private
     * @return {?}
     */
    function () {
        this.mouseExit.emit();
    };
    /**
     * @private
     * @return {?}
     */
    RaycasterGroupDirective.prototype.onMouseEnter = /**
     * @private
     * @return {?}
     */
    function () {
        this.mouseEnter.emit();
    };
    /**
     * @private
     * @return {?}
     */
    RaycasterGroupDirective.prototype.onMouseDown = /**
     * @private
     * @return {?}
     */
    function () {
        this.mouseDown.emit();
    };
    /**
     * @return {?}
     */
    RaycasterGroupDirective.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.unSubscribeEvents();
    };
    RaycasterGroupDirective.decorators = [
        { type: Directive, args: [{ selector: '[atft-raycaster-group]' },] }
    ];
    /** @nocollapse */
    RaycasterGroupDirective.ctorParameters = function () { return [
        { type: AbstractObject3D },
        { type: RaycasterService }
    ]; };
    RaycasterGroupDirective.propDecorators = {
        mouseEnter: [{ type: Output }],
        mouseExit: [{ type: Output }],
        mouseDown: [{ type: Output }]
    };
    return RaycasterGroupDirective;
}());
if (false) {
    /** @type {?} */
    RaycasterGroupDirective.prototype.mouseEnter;
    /** @type {?} */
    RaycasterGroupDirective.prototype.mouseExit;
    /** @type {?} */
    RaycasterGroupDirective.prototype.mouseDown;
    /**
     * @type {?}
     * @private
     */
    RaycasterGroupDirective.prototype.host;
    /**
     * @type {?}
     * @private
     */
    RaycasterGroupDirective.prototype.raycasterService;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var RaycasterCameraDirective = /** @class */ (function () {
    function RaycasterCameraDirective(host, raycasterService) {
        this.host = host;
        this.raycasterService = raycasterService;
    }
    /**
     * @return {?}
     */
    RaycasterCameraDirective.prototype.ngAfterViewInit = /**
     * @return {?}
     */
    function () {
        this.raycasterService.setCamera(this.host);
    };
    RaycasterCameraDirective.decorators = [
        { type: Directive, args: [{ selector: '[atft-raycaster-camera]' },] }
    ];
    /** @nocollapse */
    RaycasterCameraDirective.ctorParameters = function () { return [
        { type: AbstractCamera },
        { type: RaycasterService }
    ]; };
    return RaycasterCameraDirective;
}());
if (false) {
    /**
     * @type {?}
     * @private
     */
    RaycasterCameraDirective.prototype.host;
    /**
     * @type {?}
     * @private
     */
    RaycasterCameraDirective.prototype.raycasterService;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var RaycasterEnableDirective = /** @class */ (function () {
    function RaycasterEnableDirective(raycasterService) {
        this.raycasterService = raycasterService;
    }
    /**
     * @return {?}
     */
    RaycasterEnableDirective.prototype.ngAfterViewInit = /**
     * @return {?}
     */
    function () {
        this.raycasterService.enable();
    };
    RaycasterEnableDirective.decorators = [
        { type: Directive, args: [{ selector: '[atft-raycaster-enable]' },] }
    ];
    /** @nocollapse */
    RaycasterEnableDirective.ctorParameters = function () { return [
        { type: RaycasterService }
    ]; };
    return RaycasterEnableDirective;
}());
if (false) {
    /**
     * @type {?}
     * @private
     */
    RaycasterEnableDirective.prototype.raycasterService;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var AtftRaycasterModule = /** @class */ (function () {
    function AtftRaycasterModule() {
    }
    AtftRaycasterModule.decorators = [
        { type: NgModule, args: [{
                    imports: [
                        CommonModule
                    ],
                    declarations: [
                        RaycasterGroupDirective,
                        RaycasterCameraDirective,
                        RaycasterEnableDirective
                    ],
                    providers: [
                        RaycasterService
                    ],
                    exports: [
                        RaycasterGroupDirective,
                        RaycasterCameraDirective,
                        RaycasterEnableDirective
                    ]
                },] }
    ];
    return AtftRaycasterModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// NOTE: In case of "ERROR in Unexpected value 'undefined' exported by the module 'AtftModule" fix imports (do not import index.ts)
var AtftModule = /** @class */ (function () {
    function AtftModule() {
    }
    AtftModule.decorators = [
        { type: NgModule, args: [{
                    imports: [
                        AtftCameraModule,
                        AtftObjectModule,
                        AtftControlModule,
                        AtftPipeModule,
                        AtftRendererModule,
                        AtftAnimationModule,
                        AtftRaycasterModule
                    ],
                    exports: [
                        AtftCameraModule,
                        AtftObjectModule,
                        AtftControlModule,
                        AtftPipeModule,
                        AtftRendererModule,
                        AtftAnimationModule,
                        AtftRaycasterModule
                    ]
                },] }
    ];
    return AtftModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @record
 */
function StatsResults() { }
if (false) {
    /** @type {?} */
    StatsResults.prototype.ms;
    /** @type {?} */
    StatsResults.prototype.count;
    /** @type {?} */
    StatsResults.prototype.callsPerSecond;
}
var StatsService = /** @class */ (function () {
    function StatsService() {
        this.ms = 0;
        this.count = 0;
    }
    /**
     * @return {?}
     */
    StatsService.prototype.start = /**
     * @return {?}
     */
    function () {
        this.lastTime = Date.now();
    };
    /**
     * @return {?}
     */
    StatsService.prototype.end = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var deltaMs = Date.now() - this.lastTime;
        this.ms += deltaMs;
        this.count++;
    };
    /**
     * @return {?}
     */
    StatsService.prototype.getStats = /**
     * @return {?}
     */
    function () {
        return {
            ms: this.ms,
            count: this.count,
            callsPerSecond: Math.round(this.count / (this.ms / 1000))
        };
    };
    /**
     * @return {?}
     */
    StatsService.prototype.reset = /**
     * @return {?}
     */
    function () {
        this.ms = 0;
        this.count = 0;
    };
    StatsService.decorators = [
        { type: Injectable }
    ];
    return StatsService;
}());
if (false) {
    /**
     * @type {?}
     * @private
     */
    StatsService.prototype.lastTime;
    /**
     * @type {?}
     * @private
     */
    StatsService.prototype.ms;
    /**
     * @type {?}
     * @private
     */
    StatsService.prototype.count;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { AnimationService, AtftModule, AxesHelperComponent, BoxMeshComponent, Css3dVideoMeshComponent, CylinderMeshComponent, Deg2RadPipe, DirectionalLightComponent, EmptyComponent, FrameMeshComponent, GridHelperComponent, HemisphereLightComponent, LineConnectorComponent, MapControlsComponent, MeshLineConnectorComponent, ObjLoaderComponent, ObjectLoaderComponent, OrbitControlsComponent, PerspectiveCameraComponent, PlaneMeshComponent, PointLightComponent, Rad2DegPipe, RaycasterCameraDirective, RaycasterEnableDirective, RaycasterGroupDirective, RaycasterService, RendererCanvasComponent, RendererService, SVGLoaderComponent, SceneComponent, SphereMeshComponent, StatsService, TorusMeshComponent, appliedColor, appliedMaterial, calculateSize, fixCenter, scaleToFit, AtftCameraModule as a, PerspectiveCameraComponent as b, BoxMeshComponent as ba, AbstractMesh as bb, CylinderMeshComponent as bc, FrameMeshComponent as bd, PlaneMeshComponent as be, SphereMeshComponent as bf, TorusMeshComponent as bg, Css3dVideoMeshComponent as bh, AbstractCss3dMesh as bi, AtftTextModule as bj, TextMeshComponent as bk, SceneComponent as bl, AtftControlModule as bm, OrbitControlsComponent as bn, AbstractOrbitControls as bo, RendererCanvasComponent as bp, RaycasterService as bq, MapControlsComponent as br, AtftPipeModule as bs, Deg2RadPipe as bt, Rad2DegPipe as bu, AtftRendererModule as bv, AtftAnimationModule as bw, AtftRaycasterModule as bx, RaycasterGroupDirective as by, RaycasterCameraDirective as bz, AbstractCamera as c, RaycasterEnableDirective as ca, RendererService as d, AtftObjectModule as e, AtftConnectorModule as f, LineConnectorComponent as g, AbstractConnector as h, AbstractObject3D as i, MeshLineConnectorComponent as j, AnimationService as k, AtftHelperModule as l, AxesHelperComponent as m, EmptyComponent as n, GridHelperComponent as o, AtftLightModule as p, DirectionalLightComponent as q, HemisphereLightComponent as r, PointLightComponent as s, AtftLoaderModule as t, ObjLoaderComponent as u, AbstractModelLoader as v, AbstractLazyObject3D as w, ObjectLoaderComponent as x, SVGLoaderComponent as y, AtftMeshModule as z };
//# sourceMappingURL=atft.js.map
