/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import * as tslib_1 from "tslib";
import { Component, forwardRef, Input } from '@angular/core';
import { AbstractObject3D } from '../abstract-object-3d';
import { AbstractModelLoader } from './abstract-model-loader';
import { SVGLoader } from 'three/examples/jsm/loaders/SVGLoader';
import * as THREE from 'three';
import { appliedColor, appliedMaterial } from '../../util';
import { fixCenter } from '../../util/fix-center';
import { scaleToFit } from '../../util/scale-to-fit';
import { RendererService } from '../../renderer/renderer.service';
var SVGLoaderComponent = /** @class */ (function (_super) {
    tslib_1.__extends(SVGLoaderComponent, _super);
    function SVGLoaderComponent(rendererService) {
        var _this = _super.call(this, rendererService) || this;
        _this.rendererService = rendererService;
        _this._overrideMaterialColor = undefined;
        _this.material = 'basic';
        _this.depthWrite = true;
        _this.centered = true;
        _this.loader = new SVGLoader();
        return _this;
    }
    Object.defineProperty(SVGLoaderComponent.prototype, "overrideMaterialColor", {
        get: /**
         * @return {?}
         */
        function () {
            return this._overrideMaterialColor;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._overrideMaterialColor = value;
            this.startLoading();
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @protected
     * @return {?}
     */
    SVGLoaderComponent.prototype.loadLazyObject = /**
     * @protected
     * @return {?}
     */
    function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var _this = this;
            return tslib_1.__generator(this, function (_a) {
                // console.log('ObjectLoaderComponent.loadLazyObject');
                return [2 /*return*/, new Promise((/**
                     * @param {?} resolve
                     * @param {?} reject
                     * @return {?}
                     */
                    function (resolve, reject) {
                        _this.loader.load(_this.model, (/**
                         * @param {?} data
                         * @return {?}
                         */
                        function (data) {
                            /** @type {?} */
                            var paths = data.paths;
                            /** @type {?} */
                            var group = new THREE.Group();
                            for (var i = 0; i < paths.length; i++) {
                                // NOTE: It seems that ShapePath does not includes typed color, cast to any as workaround
                                /** @type {?} */
                                var path = paths[i];
                                /** @type {?} */
                                var color = (_this._overrideMaterialColor ? appliedColor(_this._overrideMaterialColor) : path.color);
                                /** @type {?} */
                                var material = appliedMaterial(color, _this.material, _this.depthWrite);
                                /** @type {?} */
                                var shapes = path.toShapes(true, {});
                                for (var j = 0; j < shapes.length; j++) {
                                    /** @type {?} */
                                    var shape = shapes[j];
                                    /** @type {?} */
                                    var geometry = new THREE.ShapeBufferGeometry(shape);
                                    /** @type {?} */
                                    var mesh = new THREE.Mesh(geometry, material);
                                    group.add(mesh);
                                }
                            }
                            if (_this.maxX || _this.maxY) {
                                scaleToFit(group, new THREE.Vector3(_this.maxX, _this.maxY, 0));
                            }
                            if (_this.centered) {
                                fixCenter(group);
                            }
                            resolve(group);
                        }), undefined, reject);
                    }))];
            });
        });
    };
    SVGLoaderComponent.decorators = [
        { type: Component, args: [{
                    selector: 'atft-svg-loader',
                    providers: [{ provide: AbstractObject3D, useExisting: forwardRef((/**
                             * @return {?}
                             */
                            function () { return SVGLoaderComponent; })) }],
                    template: '<ng-content></ng-content>'
                }] }
    ];
    /** @nocollapse */
    SVGLoaderComponent.ctorParameters = function () { return [
        { type: RendererService }
    ]; };
    SVGLoaderComponent.propDecorators = {
        overrideMaterialColor: [{ type: Input }],
        material: [{ type: Input }],
        depthWrite: [{ type: Input }],
        maxX: [{ type: Input }],
        maxY: [{ type: Input }],
        centered: [{ type: Input }]
    };
    return SVGLoaderComponent;
}(AbstractModelLoader));
export { SVGLoaderComponent };
if (false) {
    /**
     * @type {?}
     * @private
     */
    SVGLoaderComponent.prototype._overrideMaterialColor;
    /** @type {?} */
    SVGLoaderComponent.prototype.material;
    /** @type {?} */
    SVGLoaderComponent.prototype.depthWrite;
    /** @type {?} */
    SVGLoaderComponent.prototype.maxX;
    /** @type {?} */
    SVGLoaderComponent.prototype.maxY;
    /** @type {?} */
    SVGLoaderComponent.prototype.centered;
    /**
     * @type {?}
     * @private
     */
    SVGLoaderComponent.prototype.loader;
    /**
     * @type {?}
     * @protected
     */
    SVGLoaderComponent.prototype.rendererService;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3ZnLWxvYWRlci5jb21wb25lbnQuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9hdGZ0LyIsInNvdXJjZXMiOlsibGliL29iamVjdC9sb2FkZXIvc3ZnLWxvYWRlci5jb21wb25lbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQSxPQUFPLEVBQUMsU0FBUyxFQUFFLFVBQVUsRUFBRSxLQUFLLEVBQUMsTUFBTSxlQUFlLENBQUM7QUFDM0QsT0FBTyxFQUFDLGdCQUFnQixFQUFDLE1BQU0sdUJBQXVCLENBQUM7QUFDdkQsT0FBTyxFQUFDLG1CQUFtQixFQUFDLE1BQU0seUJBQXlCLENBQUM7QUFDNUQsT0FBTyxFQUFDLFNBQVMsRUFBQyxNQUFNLHNDQUFzQyxDQUFDO0FBRS9ELE9BQU8sS0FBSyxLQUFLLE1BQU0sT0FBTyxDQUFDO0FBQy9CLE9BQU8sRUFBQyxZQUFZLEVBQUUsZUFBZSxFQUFDLE1BQU0sWUFBWSxDQUFDO0FBQ3pELE9BQU8sRUFBQyxTQUFTLEVBQUMsTUFBTSx1QkFBdUIsQ0FBQztBQUNoRCxPQUFPLEVBQUMsVUFBVSxFQUFDLE1BQU0seUJBQXlCLENBQUM7QUFDbkQsT0FBTyxFQUFDLGVBQWUsRUFBQyxNQUFNLGlDQUFpQyxDQUFDO0FBRWhFO0lBS3dDLDhDQUFtQjtJQWdDekQsNEJBQ1ksZUFBZ0M7UUFENUMsWUFHRSxrQkFBTSxlQUFlLENBQUMsU0FDdkI7UUFIVyxxQkFBZSxHQUFmLGVBQWUsQ0FBaUI7UUFyQnBDLDRCQUFzQixHQUFXLFNBQVMsQ0FBQztRQUluRCxjQUFRLEdBQUcsT0FBTyxDQUFDO1FBR25CLGdCQUFVLEdBQUcsSUFBSSxDQUFDO1FBU2xCLGNBQVEsR0FBRyxJQUFJLENBQUM7UUFFUixZQUFNLEdBQUcsSUFBSSxTQUFTLEVBQUUsQ0FBQzs7SUFNakMsQ0FBQztJQWxDRCxzQkFDSSxxREFBcUI7Ozs7UUFEekI7WUFFRSxPQUFPLElBQUksQ0FBQyxzQkFBc0IsQ0FBQztRQUNyQyxDQUFDOzs7OztRQUVELFVB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b3VyY2VzQ29udGVudCI6WyJpbXBvcnQge0NvbXBvbmVudCwgZm9yd2FyZFJlZiwgSW5wdXR9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQge0Fic3RyYWN0T2JqZWN0M0R9IGZyb20gJy4uL2Fic3RyYWN0LW9iamVjdC0zZCc7XHJcbmltcG9ydCB7QWJzdHJhY3RNb2RlbExvYWRlcn0gZnJvbSAnLi9hYnN0cmFjdC1tb2RlbC1sb2FkZXInO1xyXG5pbXBvcnQge1NWR0xvYWRlcn0gZnJvbSAndGhyZWUvZXhhbXBsZXMvanNtL2xvYWRlcnMvU1ZHTG9hZGVyJztcclxuXHJcbmltcG9ydCAqIGFzIFRIUkVFIGZyb20gJ3RocmVlJztcclxuaW1wb3J0IHthcHBsaWVkQ29sb3IsIGFwcGxpZWRNYXRlcmlhbH0gZnJvbSAnLi4vLi4vdXRpbCc7XHJcbmltcG9ydCB7Zml4Q2VudGVyfSBmcm9tICcuLi8uLi91dGlsL2ZpeC1jZW50ZXInO1xyXG5pbXBvcnQge3NjYWxlVG9GaXR9IGZyb20gJy4uLy4uL3V0aWwvc2NhbGUtdG8tZml0JztcclxuaW1wb3J0IHtSZW5kZXJlclNlcnZpY2V9IGZyb20gJy4uLy4uL3JlbmRlcmVyL3JlbmRlcmVyLnNlcnZpY2UnO1xyXG5cclxuQENvbXBvbmVudCh7XHJcbiAgc2VsZWN0b3I6ICdhdGZ0LXN2Zy1sb2FkZXInLFxyXG4gIHByb3ZpZGVyczogW3twcm92aWRlOiBBYnN0cmFjdE9iamVjdDNELCB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBTVkdMb2FkZXJDb21wb25lbnQpfV0sXHJcbiAgdGVtcGxhdGU6ICc8bmctY29udGVudD48L25nLWNvbnRlbnQ+J1xyXG59KVxyXG5leHBvcnQgY2xhc3MgU1ZHTG9hZGVyQ29tcG9uZW50IGV4dGVuZHMgQWJzdHJhY3RNb2RlbExvYWRlciB7XHJcblxyXG4gIEBJbnB1dCgpXHJcbiAgZ2V0IG92ZXJyaWRlTWF0ZXJpYWxDb2xvcigpOiBudW1iZXIge1xyXG4gICAgcmV0dXJuIHRoaXMuX292ZXJyaWRlTWF0ZXJpYWxDb2xvcjtcclxuICB9XHJcblxyXG4gIHNldCBvdmVycmlkZU1hdGVyaWFsQ29sb3IodmFsdWU6IG51bWJlcikge1xyXG4gICAgdGhpcy5fb3ZlcnJpZGVNYXRlcmlhbENvbG9yID0gdmFsdWU7XHJcbiAgICB0aGlzLnN0YXJ0TG9hZGluZygpO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBfb3ZlcnJpZGVNYXRlcmlhbENvbG9yOiBudW1iZXIgPSB1bmRlZmluZWQ7XHJcblxyXG5cclxuICBASW5wdXQoKVxyXG4gIG1hdGVyaWFsID0gJ2Jhc2ljJztcclxuXHJcbiAgQElucHV0KClcclxuICBkZXB0aFdyaXRlID0gdHJ1ZTtcclxuXHJcbiAgQElucHV0KClcclxuICBtYXhYOiBudW1iZXI7XHJcblxyXG4gIEBJbnB1dCgpXHJcbiAgbWF4WTogbnVtYmVyO1xyXG5cclxuICBASW5wdXQoKVxyXG4gIGNlbnRlcmVkID0gdHJ1ZTtcclxuXHJcbiAgcHJpdmF0ZSBsb2FkZXIgPSBuZXcgU1ZHTG9hZGVyKCk7XHJcblxyXG4gIGNvbnN0cnVjdG9yKFxyXG4gICAgcHJvdGVjdGVkIHJlbmRlcmVyU2VydmljZTogUmVuZGVyZXJTZXJ2aWNlXHJcbiAgKSB7XHJcbiAgICBzdXBlcihyZW5kZXJlclNlcnZpY2UpO1xyXG4gIH1cclxuXHJcbiAgcHJvdGVjdGVkIGFzeW5jIGxvYWRMYXp5T2JqZWN0KCkge1xyXG4gICAgLy8gY29uc29sZS5sb2coJ09iamVjdExvYWRlckNvbXBvbmVudC5sb2FkTGF6eU9iamVjdCcpO1xyXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlPFRIUkVFLk9iamVjdDNEPigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgIHRoaXMubG9hZGVyLmxvYWQodGhpcy5tb2RlbCwgZGF0YSA9PiB7XHJcbiAgICAgICAgICBjb25zdCBwYXRocyA9IGRhdGEucGF0aHM7XHJcbiAgICAgICAgICBjb25zdCBncm91cCA9IG5ldyBUSFJFRS5Hcm91cCgpO1xyXG5cclxuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGF0aHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgLy8gTk9URTogSXQgc2VlbXMgdGhhdCBTaGFwZVBhdGggZG9lcyBub3QgaW5jbHVkZXMgdHlwZWQgY29sb3IsIGNhc3QgdG8gYW55IGFzIHdvcmthcm91bmRcclxuICAgICAgICAgICAgY29uc3QgcGF0aDogYW55ID0gcGF0aHNbaV07XHJcbiAgICAgICAgICAgIGNvbnN0IGNvbG9yID0gKHRoaXMuX292ZXJyaWRlTWF0ZXJpYWxDb2xvciA/IGFwcGxpZWRDb2xvcih0aGlzLl9vdmVycmlkZU1hdGVyaWFsQ29sb3IpIDogcGF0aC5jb2xvcik7XHJcbiAgICAgICAgICAgIGNvbnN0IG1hdGVyaWFsID0gYXBwbGllZE1hdGVyaWFsKGNvbG9yLCB0aGlzLm1hdGVyaWFsLCB0aGlzLmRlcHRoV3JpdGUpO1xyXG4gICAgICAgICAgICBjb25zdCBzaGFwZXMgPSBwYXRoLnRvU2hhcGVzKHRydWUsIHt9KTtcclxuXHJcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgc2hhcGVzLmxlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgICAgICAgY29uc3Qgc2hhcGUgPSBzaGFwZXNbal07XHJcbiAgICAgICAgICAgICAgY29uc3QgZ2VvbWV0cnkgPSBuZXcgVEhSRUUuU2hhcGVCdWZmZXJHZW9tZXRyeShzaGFwZSk7XHJcbiAgICAgICAgICAgICAgY29uc3QgbWVzaCA9IG5ldyBUSFJFRS5NZXNoKGdlb21ldHJ5LCBtYXRlcmlhbCk7XHJcbiAgICAgICAgICAgICAgZ3JvdXAuYWRkKG1lc2gpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgaWYgKHRoaXMubWF4WCB8fCB0aGlzLm1heFkpIHtcclxuICAgICAgICAgICAgc2NhbGVUb0ZpdChncm91cCwgbmV3IFRIUkVFLlZlY3RvcjModGhpcy5tYXhYLCB0aGlzLm1heFksIDApKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGlmICh0aGlzLmNlbnRlcmVkKSB7XHJcbiAgICAgICAgICAgIGZpeENlbnRlcihncm91cCk7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgcmVzb2x2ZShncm91cCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICB1bmRlZmluZWQsXHJcbiAgICAgICAgcmVqZWN0KTtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcblxyXG59XHJcbiJdfQ==