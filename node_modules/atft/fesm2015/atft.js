import { Input, Injectable, Component, forwardRef, NgModule, EventEmitter, ContentChildren, ViewChildren, Output, ViewChild, HostListener, ContentChild, Pipe, Directive } from '@angular/core';
import { CommonModule } from '@angular/common';
import { WebGLRenderer, PCFSoftShadowMap, PerspectiveCamera, Geometry, DoubleSide, NormalBlending, Mesh, LineBasicMaterial, Line, AxesHelper, Object3D, GridHelper, Color, MeshLambertMaterial, MeshBasicMaterial, MeshPhongMaterial, Box3, Vector3, PointLight, HemisphereLight, DirectionalLight, ObjectLoader, Group, ShapeBufferGeometry, BoxGeometry, CylinderGeometry, Shape, PlaneBufferGeometry, SphereGeometry, TorusGeometry, FontLoader, TextGeometry, Scene, Fog, Raycaster } from 'three';
import { CSS3DRenderer, CSS3DObject } from 'three/examples/jsm/renderers/CSS3DRenderer';
import { MeshLine, MeshLineMaterial } from 'three.meshline';
import { __awaiter } from 'tslib';
import { OBJLoader } from 'three/examples/jsm/loaders/OBJLoader';
import { MTLLoader } from 'three/examples/jsm/loaders/MTLLoader';
import { SVGLoader } from 'three/examples/jsm/loaders/SVGLoader';
import { OrbitControls, MapControls } from 'three/examples/jsm/controls/OrbitControls';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @abstract
 * @template T
 */
class AbstractCamera {
    /**
     * @param {?} rendererService
     */
    constructor(rendererService) {
        this.rendererService = rendererService;
        this.zAxisUp = false;
        // console.log('AbstractCamera.constructor');
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        // console.log('AbstractCamera.ngAfterViewInit');
        this.createCamera();
        this.applyZAxisUp();
        this.applyPosition();
        // TODO: Directive?
        this.rendererService.setCamera(this);
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        /** @type {?} */
        let mustRerender = false;
        if (['positionX', 'positionY', 'positionZ'].some((/**
         * @param {?} propName
         * @return {?}
         */
        propName => propName in changes))) {
            this.applyPosition();
            mustRerender = true;
        }
        if (mustRerender) {
            this.rendererService.render();
        }
    }
    /**
     * @protected
     * @return {?}
     */
    applyPosition() {
        if (this.camera) {
            this.camera.position.set(this.positionX || 0, this.positionY || 0, this.positionZ || 0);
        }
    }
    /**
     * @protected
     * @return {?}
     */
    applyZAxisUp() {
        if (this.camera && this.zAxisUp) {
            // Z axis up (similarly to 3D Creation Software: Blender, 3DS Max)
            this.camera.up.set(0, 0, 1);
        }
    }
}
AbstractCamera.propDecorators = {
    positionX: [{ type: Input }],
    positionY: [{ type: Input }],
    positionZ: [{ type: Input }],
    zAxisUp: [{ type: Input }]
};
if (false) {
    /** @type {?} */
    AbstractCamera.prototype.camera;
    /** @type {?} */
    AbstractCamera.prototype.positionX;
    /** @type {?} */
    AbstractCamera.prototype.positionY;
    /** @type {?} */
    AbstractCamera.prototype.positionZ;
    /** @type {?} */
    AbstractCamera.prototype.zAxisUp;
    /**
     * @type {?}
     * @protected
     */
    AbstractCamera.prototype.rendererService;
    /**
     * @abstract
     * @protected
     * @return {?}
     */
    AbstractCamera.prototype.createCamera = function () { };
    /**
     * @abstract
     * @param {?} aspect
     * @return {?}
     */
    AbstractCamera.prototype.updateAspectRatio = function (aspect) { };
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/* TODO: Refactor to pair
interface RendererPair {
  scene: SceneComponent;
  camera: AbstractCamera<any>;
  webGlRenderer: THREE.Renderer;
  layers: Array<number>;
}
*/
class RendererService {
    constructor() {
        this.init = false;
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
    }
    /**
     * @param {?} scene
     * @return {?}
     */
    setScene(scene) {
        this.scene = scene;
    }
    /**
     * @param {?} camera
     * @return {?}
     */
    setCamera(camera) {
        this.camera = camera;
        this.camera.updateAspectRatio(this.aspect);
    }
    /**
     * @return {?}
     */
    render() {
        if (this.init && this.scene && this.camera) {
            //  console.log('render');
            this.webGlRenderer.render(this.scene.getObject(), this.camera.camera);
            this.css3dRenderer.render(this.scene.getObject(), this.camera.camera);
        }
    }
    /**
     * @param {?} canvas
     * @return {?}
     */
    initialize(canvas) {
        // console.log('RendererComponent.initialize');
        // TODO: Multiple renderers
        this.webGlRenderer = new WebGLRenderer({
            canvas: canvas,
            antialias: true,
            alpha: true
        });
        this.webGlRenderer.setPixelRatio(devicePixelRatio);
        this.webGlRenderer.setSize(canvas.clientWidth, canvas.clientHeight, false);
        // TODO: props
        this.webGlRenderer.shadowMap.enabled = false;
        this.webGlRenderer.shadowMap.autoUpdate = false;
        this.webGlRenderer.shadowMap.type = PCFSoftShadowMap;
        this.webGlRenderer.setClearColor(0x000000, 0);
        this.webGlRenderer.autoClear = true;
        canvas.style.zIndex = '2';
        // ------------------------------ START
        this.css3dRenderer = new CSS3DRenderer();
        this.css3dRenderer.setSize(window.innerWidth, window.innerHeight);
        this.css3dRenderer.domElement.style.position = 'absolute';
        this.css3dRenderer.domElement.style.top = '0';
        this.css3dRenderer.domElement.style.zIndex = '1';
        canvas.parentElement.appendChild(this.css3dRenderer.domElement);
        // ------------------------------ END
        this.updateChildCamerasAspectRatio(canvas);
        this.init = true;
        this.render();
    }
    /**
     * @param {?} canvas
     * @param {?} size
     * @return {?}
     */
    resize(canvas, size) {
        canvas.style.width = size;
        canvas.style.height = size;
        /** @type {?} */
        const width = canvas.clientWidth;
        /** @type {?} */
        const height = canvas.clientHeight;
        this.webGlRenderer.setSize(width, height, true);
        this.css3dRenderer.setSize(width, height);
        this.updateChildCamerasAspectRatio(canvas);
        this.render();
    }
    /**
     * @private
     * @param {?} canvas
     * @return {?}
     */
    calculateAspectRatio(canvas) {
        /** @type {?} */
        const height = canvas.clientHeight;
        if (height === 0) {
            return 0;
        }
        this.aspect = canvas.clientWidth / canvas.clientHeight;
    }
    /**
     * @private
     * @param {?} canvas
     * @return {?}
     */
    updateChildCamerasAspectRatio(canvas) {
        this.calculateAspectRatio(canvas);
        if (this.camera) {
            this.camera.updateAspectRatio(this.aspect);
        }
    }
}
RendererService.decorators = [
    { type: Injectable }
];
/** @nocollapse */
RendererService.ctorParameters = () => [];
if (false) {
    /**
     * @type {?}
     * @private
     */
    RendererService.prototype.init;
    /**
     * @type {?}
     * @private
     */
    RendererService.prototype.scene;
    /**
     * @type {?}
     * @private
     */
    RendererService.prototype.camera;
    /**
     * @type {?}
     * @private
     */
    RendererService.prototype.webGlRenderer;
    /**
     * @type {?}
     * @private
     */
    RendererService.prototype.css3dRenderer;
    /**
     * @type {?}
     * @private
     */
    RendererService.prototype.aspect;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class PerspectiveCameraComponent extends AbstractCamera {
    /**
     * @param {?} rendererService
     */
    constructor(rendererService) {
        super(rendererService);
        this.rendererService = rendererService;
    }
    /**
     * @protected
     * @return {?}
     */
    createCamera() {
        // console.log('PerspectiveCameraComponent.createCamera');
        // let aspectRatio = undefined; // Updated later
        this.camera = new PerspectiveCamera(this.fov, undefined, this.near, this.far);
    }
    /**
     * @param {?} aspect
     * @return {?}
     */
    updateAspectRatio(aspect) {
        // console.log('PerspectiveCameraComponent.updateAspectRatio: ' + aspect);
        this.camera.aspect = aspect;
        this.camera.updateProjectionMatrix();
    }
}
PerspectiveCameraComponent.decorators = [
    { type: Component, args: [{
                selector: 'atft-perspective-camera',
                providers: [{ provide: AbstractCamera, useExisting: forwardRef((/**
                         * @return {?}
                         */
                        () => PerspectiveCameraComponent)) }],
                template: '<ng-content></ng-content>'
            }] }
];
/** @nocollapse */
PerspectiveCameraComponent.ctorParameters = () => [
    { type: RendererService }
];
PerspectiveCameraComponent.propDecorators = {
    fov: [{ type: Input }],
    near: [{ type: Input }],
    far: [{ type: Input }]
};
if (false) {
    /** @type {?} */
    PerspectiveCameraComponent.prototype.fov;
    /** @type {?} */
    PerspectiveCameraComponent.prototype.near;
    /** @type {?} */
    PerspectiveCameraComponent.prototype.far;
    /**
     * @type {?}
     * @protected
     */
    PerspectiveCameraComponent.prototype.rendererService;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class AtftCameraModule {
}
AtftCameraModule.decorators = [
    { type: NgModule, args: [{
                declarations: [
                    PerspectiveCameraComponent
                ],
                imports: [
                    CommonModule
                ],
                exports: [
                    PerspectiveCameraComponent
                ]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @abstract
 * @template T
 */
class AbstractObject3D {
    /**
     * @param {?} rendererService
     */
    constructor(rendererService) {
        this.rendererService = rendererService;
        this.changed = new EventEmitter();
        // console.log('AbstractObject3D.constructor');
        this.changed.subscribe((/**
         * @return {?}
         */
        () => {
            this.rendererService.render();
        }));
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (!this.object) {
            return;
        }
        /** @type {?} */
        let modified = false;
        if (['rotateX', 'rotateY', 'rotateZ'].some((/**
         * @param {?} propName
         * @return {?}
         */
        propName => propName in changes))) {
            this.applyRotation();
            modified = true;
        }
        if (['translateX', 'translateY', 'translateZ'].some((/**
         * @param {?} propName
         * @return {?}
         */
        propName => propName in changes))) {
            this.applyTranslation();
            modified = true;
        }
        if (modified) {
            this.changed.emit();
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        // console.log('AbstractObject3D.OnDestroy');
        if (this.object && this.object.parent) {
            this.object.parent.remove(this.object);
        }
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        // console.log('AbstractObject3D.ngAfterViewInit ' + this.name);
        this.object = this.newObject3DInstance();
        this.applyTranslation();
        this.applyRotation();
        this.collectChilds();
        this.afterInit();
    }
    /**
     * @return {?}
     */
    collectChilds() {
        // console.log('Collect childs for', this.name);
        if (this.childNodes !== undefined && this.childNodes.length > 1) {
            this.childNodes.filter((/**
             * @param {?} i
             * @return {?}
             */
            i => i !== this && i.getObject() !== undefined)).forEach((/**
             * @param {?} i
             * @return {?}
             */
            i => {
                // console.log('Add childNodes for', this.name, i);
                this.addChild(i.getObject());
            }));
        }
        else {
            // console.log("No child Object3D for: " + this.constructor.label);
        }
        if (this.viewChilds !== undefined && this.viewChilds.length > 0) {
            this.viewChilds.filter((/**
             * @param {?} i
             * @return {?}
             */
            i => i !== this
                && i.getObject() !== undefined
                && !i.getObject().parent /* direct childs only */)).forEach((/**
             * @param {?} i
             * @return {?}
             */
            i => {
                // console.log('Add viewChilds for', this.name, i);
                this.addChild(i.getObject());
            }));
        }
        else {
            // console.log("No child Object3D for: " + this.constructor.label);
        }
    }
    /**
     * @private
     * @return {?}
     */
    applyRotation() {
        this.object.rotation.set(this.rotateX || 0, this.rotateY || 0, this.rotateZ || 0, 'XYZ');
    }
    /**
     * @private
     * @return {?}
     */
    applyTranslation() {
        this.object.position.set(this.translateX || 0, this.translateY || 0, this.translateZ || 0);
    }
    /**
     * @param {?} object
     * @return {?}
     */
    addChild(object) {
        this.object.add(object);
    }
    /**
     * @protected
     * @param {?} object
     * @return {?}
     */
    removeChild(object) {
        this.object.remove(object);
    }
    /**
     * @return {?}
     */
    getObject() {
        return this.object;
    }
    /**
     * @protected
     * @return {?}
     */
    afterInit() {
        // this.changed.emit();
    }
}
AbstractObject3D.propDecorators = {
    childNodes: [{ type: ContentChildren, args: [AbstractObject3D, { descendants: false },] }],
    viewChilds: [{ type: ViewChildren, args: [AbstractObject3D,] }],
    rotateX: [{ type: Input }],
    rotateY: [{ type: Input }],
    rotateZ: [{ type: Input }],
    translateX: [{ type: Input }],
    translateY: [{ type: Input }],
    translateZ: [{ type: Input }],
    name: [{ type: Input }],
    changed: [{ type: Output }]
};
if (false) {
    /** @type {?} */
    AbstractObject3D.prototype.childNodes;
    /** @type {?} */
    AbstractObject3D.prototype.viewChilds;
    /**
     * Rotation in Euler angles (radians) with order X, Y, Z.
     * @type {?}
     */
    AbstractObject3D.prototype.rotateX;
    /** @type {?} */
    AbstractObject3D.prototype.rotateY;
    /** @type {?} */
    AbstractObject3D.prototype.rotateZ;
    /**
     * Translate the geometry. This is typically done as a one time operation, and not during a loop.
     * @type {?}
     */
    AbstractObject3D.prototype.translateX;
    /** @type {?} */
    AbstractObject3D.prototype.translateY;
    /** @type {?} */
    AbstractObject3D.prototype.translateZ;
    /** @type {?} */
    AbstractObject3D.prototype.name;
    /** @type {?} */
    AbstractObject3D.prototype.changed;
    /**
     * @type {?}
     * @private
     */
    AbstractObject3D.prototype.object;
    /**
     * @type {?}
     * @protected
     */
    AbstractObject3D.prototype.rendererService;
    /**
     * @abstract
     * @protected
     * @return {?}
     */
    AbstractObject3D.prototype.newObject3DInstance = function () { };
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @abstract
 * @template T
 */
class AbstractConnector extends AbstractObject3D {
    /**
     * @protected
     * @return {?}
     */
    newObject3DInstance() {
        /** @type {?} */
        const mesh = this.createConnectorObject();
        this.watchObjects();
        return mesh;
    }
    /**
     * @private
     * @return {?}
     */
    watchObjects() {
        this.source.changed.subscribe((/**
         * @param {?} item
         * @return {?}
         */
        item => {
            this.updateLineGeometry();
        }));
        this.target.changed.subscribe((/**
         * @param {?} item
         * @return {?}
         */
        item => {
            this.updateLineGeometry();
        }));
    }
    /**
     * @protected
     * @return {?}
     */
    getLineGeometry() {
        /** @type {?} */
        const geo = new Geometry();
        if (!this.source || !this.target) {
            throw new Error('AbstractConnector: source or target inputs are missing!');
        }
        geo.vertices.push(this.source.getObject().position);
        geo.vertices.push(this.target.getObject().position);
        return geo;
    }
}
AbstractConnector.propDecorators = {
    source: [{ type: Input }],
    target: [{ type: Input }]
};
if (false) {
    /** @type {?} */
    AbstractConnector.prototype.source;
    /** @type {?} */
    AbstractConnector.prototype.target;
    /**
     * Create line mesh
     * @abstract
     * @return {?}
     */
    AbstractConnector.prototype.createConnectorObject = function () { };
    /**
     * If at least one line end (source or target object)  changed, then line geoetry should be updated as well
     * // TODO: Calculate only when source/target positions were changed
     * @abstract
     * @return {?}
     */
    AbstractConnector.prototype.updateLineGeometry = function () { };
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Fix color number binding issues
 * @param {?} color Color number from binding input
 * @param {?=} defaultColor default value in case of binding issues
 * @return {?}
 */
function appliedColor(color, defaultColor) {
    /** @type {?} */
    let resultColor = (defaultColor ? defaultColor : 0xffffff);
    if (color !== undefined) {
        resultColor = color * 1;
    }
    return resultColor;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Animation service emits animate event, which should be used by animated components for animation logic.
 * NOTE: this service is for the performance optimization: requestAnimationFrame and render is called once.
 */
class AnimationService {
    /**
     * @param {?} rendererService
     */
    constructor(rendererService) {
        this.rendererService = rendererService;
        /**
         * Subscribe for animation frame creation (change position and etc.)
         * Avoid render() execution, it's called only once when all components updated animation frame.
         */
        this.animate = new EventEmitter();
        this.enabled = false;
        this.animationStep = this.animationStep.bind(this);
    }
    /**
     * Start the animation loop.
     * @return {?}
     */
    start() {
        if (!this.enabled) {
            this.enabled = true;
            this.animationStep();
        }
    }
    /**
     * Stop all animations.
     * @return {?}
     */
    stop() {
        if (this.enabled) {
            this.enabled = false;
        }
    }
    /**
     * @private
     * @return {?}
     */
    animationStep() {
        if (this.enabled) {
            requestAnimationFrame(this.animationStep);
            if (this.animate.observers.length > 0) {
                this.animate.emit();
                /**
                 * When all components updated animation, render event is emitted.
                 * Main renderer subscribed to this event emitter.
                 */
                this.rendererService.render();
            }
        }
    }
}
AnimationService.decorators = [
    { type: Injectable }
];
/** @nocollapse */
AnimationService.ctorParameters = () => [
    { type: RendererService }
];
if (false) {
    /**
     * Subscribe for animation frame creation (change position and etc.)
     * Avoid render() execution, it's called only once when all components updated animation frame.
     * @type {?}
     */
    AnimationService.prototype.animate;
    /**
     * @type {?}
     * @private
     */
    AnimationService.prototype.enabled;
    /**
     * @type {?}
     * @private
     */
    AnimationService.prototype.rendererService;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class MeshLineConnectorComponent extends AbstractConnector {
    /**
     * @param {?} animationService
     * @param {?} rendererService
     */
    constructor(animationService, rendererService) {
        super(rendererService);
        this.animationService = animationService;
        this.rendererService = rendererService;
        this.materialColor = 0xffff00;
        this.transparent = true;
        this.opacity = 0.5;
        this.lineWidth = 0.5;
        this.depthWrite = true;
        this.depthTest = true;
        this.animated = false;
        this.animationIncrement = 0.002;
    }
    /**
     * @return {?}
     */
    createConnectorObject() {
        this.geometry = this.getLineGeometry();
        this.line = new MeshLine();
        this.line.setGeometry(this.geometry);
        this.lineMaterial = (this.animated ?
            new MeshLineMaterial({
                color: appliedColor(this.materialColor),
                transparent: this.transparent,
                opacity: this.opacity,
                lineWidth: this.lineWidth,
                depthWrite: this.depthWrite,
                depthTest: this.depthTest,
                side: DoubleSide,
                blending: NormalBlending,
                // TODO: props
                dashArray: 0.05,
                dashOffset: 0.1,
                dashRatio: 0.1
            })
            : new MeshLineMaterial({
                color: appliedColor(this.materialColor),
                transparent: this.transparent,
                opacity: this.opacity,
                lineWidth: this.lineWidth,
                depthWrite: this.depthWrite,
                depthTest: this.depthTest,
                side: DoubleSide,
                blending: NormalBlending
            }));
        /** @type {?} */
        const mesh = new Mesh(this.line.geometry, this.lineMaterial);
        if (this.animated) {
            this.animate = this.animate.bind(this);
            this.animationService.animate.subscribe(this.animate);
        }
        return mesh;
    }
    /**
     * @private
     * @return {?}
     */
    animate() {
        this.lineMaterial.uniforms.dashOffset.value += this.animationIncrement;
    }
    /**
     * @return {?}
     */
    updateLineGeometry() {
        // https://github.com/spite/THREE.MeshLine/issues/51#issuecomment-379579926
        this.line.setGeometry(this.geometry);
        this.rendererService.render();
    }
}
MeshLineConnectorComponent.decorators = [
    { type: Component, args: [{
                selector: 'atft-mesh-line-connector',
                providers: [{ provide: AbstractObject3D, useExisting: forwardRef((/**
                         * @return {?}
                         */
                        () => MeshLineConnectorComponent)) }],
                template: '<ng-content></ng-content>'
            }] }
];
/** @nocollapse */
MeshLineConnectorComponent.ctorParameters = () => [
    { type: AnimationService },
    { type: RendererService }
];
MeshLineConnectorComponent.propDecorators = {
    materialColor: [{ type: Input }],
    transparent: [{ type: Input }],
    opacity: [{ type: Input }],
    lineWidth: [{ type: Input }],
    depthWrite: [{ type: Input }],
    depthTest: [{ type: Input }],
    animated: [{ type: Input }],
    animationIncrement: [{ type: Input }]
};
if (false) {
    /** @type {?} */
    MeshLineConnectorComponent.prototype.materialColor;
    /** @type {?} */
    MeshLineConnectorComponent.prototype.transparent;
    /** @type {?} */
    MeshLineConnectorComponent.prototype.opacity;
    /** @type {?} */
    MeshLineConnectorComponent.prototype.lineWidth;
    /** @type {?} */
    MeshLineConnectorComponent.prototype.depthWrite;
    /** @type {?} */
    MeshLineConnectorComponent.prototype.depthTest;
    /** @type {?} */
    MeshLineConnectorComponent.prototype.animated;
    /** @type {?} */
    MeshLineConnectorComponent.prototype.animationIncrement;
    /**
     * @type {?}
     * @private
     */
    MeshLineConnectorComponent.prototype.geometry;
    /**
     * @type {?}
     * @private
     */
    MeshLineConnectorComponent.prototype.line;
    /**
     * @type {?}
     * @private
     */
    MeshLineConnectorComponent.prototype.lineMaterial;
    /**
     * @type {?}
     * @protected
     */
    MeshLineConnectorComponent.prototype.animationService;
    /**
     * @type {?}
     * @protected
     */
    MeshLineConnectorComponent.prototype.rendererService;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class LineConnectorComponent extends AbstractConnector {
    /**
     * @param {?} rendererService
     */
    constructor(rendererService) {
        super(rendererService);
        this.rendererService = rendererService;
        this.materialColor = 0xffff00;
    }
    /**
     * @return {?}
     */
    createConnectorObject() {
        this.geometry = this.getLineGeometry();
        /** @type {?} */
        const material = new LineBasicMaterial({
            color: appliedColor(this.materialColor),
            /**
             * NOTE: linewidth=1: Due to limitations of the OpenGL Core Profile
             * with the WebGL renderer on most platforms linewidth will always be 1
             * regardless of the set value.
             */
            linewidth: 1
        });
        /** @type {?} */
        const line = new Line(this.geometry, material);
        return line;
    }
    /**
     * @return {?}
     */
    updateLineGeometry() {
        this.geometry.verticesNeedUpdate = true;
        this.rendererService.render();
    }
}
LineConnectorComponent.decorators = [
    { type: Component, args: [{
                selector: 'atft-line-connector',
                providers: [{ provide: AbstractObject3D, useExisting: forwardRef((/**
                         * @return {?}
                         */
                        () => LineConnectorComponent)) }],
                template: '<ng-content></ng-content>'
            }] }
];
/** @nocollapse */
LineConnectorComponent.ctorParameters = () => [
    { type: RendererService }
];
LineConnectorComponent.propDecorators = {
    materialColor: [{ type: Input }]
};
if (false) {
    /** @type {?} */
    LineConnectorComponent.prototype.materialColor;
    /**
     * @type {?}
     * @private
     */
    LineConnectorComponent.prototype.geometry;
    /**
     * @type {?}
     * @protected
     */
    LineConnectorComponent.prototype.rendererService;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class AtftConnectorModule {
}
AtftConnectorModule.decorators = [
    { type: NgModule, args: [{
                declarations: [
                    LineConnectorComponent,
                    MeshLineConnectorComponent
                ],
                imports: [
                    CommonModule
                ],
                exports: [
                    LineConnectorComponent,
                    MeshLineConnectorComponent
                ]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class AxesHelperComponent extends AbstractObject3D {
    /**
     * @param {?} rendererService
     */
    constructor(rendererService) {
        super(rendererService);
        this.rendererService = rendererService;
    }
    /**
     * @protected
     * @return {?}
     */
    newObject3DInstance() {
        // console.log('AxesHelperComponent.newObject3DInstance');
        return new AxesHelper(this.size);
    }
}
AxesHelperComponent.decorators = [
    { type: Component, args: [{
                selector: 'atft-axes-helper',
                providers: [{ provide: AbstractObject3D, useExisting: forwardRef((/**
                         * @return {?}
                         */
                        () => AxesHelperComponent)) }],
                template: '<ng-content></ng-content>'
            }] }
];
/** @nocollapse */
AxesHelperComponent.ctorParameters = () => [
    { type: RendererService }
];
AxesHelperComponent.propDecorators = {
    size: [{ type: Input }]
};
if (false) {
    /** @type {?} */
    AxesHelperComponent.prototype.size;
    /**
     * @type {?}
     * @protected
     */
    AxesHelperComponent.prototype.rendererService;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class EmptyComponent extends AbstractObject3D {
    /**
     * @param {?} rendererService
     */
    constructor(rendererService) {
        super(rendererService);
        this.rendererService = rendererService;
    }
    /**
     * @protected
     * @return {?}
     */
    newObject3DInstance() {
        return new Object3D();
    }
}
EmptyComponent.decorators = [
    { type: Component, args: [{
                selector: 'atft-empty',
                providers: [{ provide: AbstractObject3D, useExisting: forwardRef((/**
                         * @return {?}
                         */
                        () => EmptyComponent)) }],
                template: '<ng-content></ng-content>'
            }] }
];
/** @nocollapse */
EmptyComponent.ctorParameters = () => [
    { type: RendererService }
];
if (false) {
    /**
     * @type {?}
     * @protected
     */
    EmptyComponent.prototype.rendererService;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class GridHelperComponent extends AbstractObject3D {
    /**
     * @param {?} rendererService
     */
    constructor(rendererService) {
        super(rendererService);
        this.rendererService = rendererService;
    }
    /**
     * @protected
     * @return {?}
     */
    newObject3DInstance() {
        // console.log('GridHelperComponent.newObject3DInstance');
        return new GridHelper(this.size, this.divisions);
    }
}
GridHelperComponent.decorators = [
    { type: Component, args: [{
                selector: 'atft-grid-helper',
                providers: [{ provide: AbstractObject3D, useExisting: forwardRef((/**
                         * @return {?}
                         */
                        () => GridHelperComponent)) }],
                template: '<ng-content></ng-content>'
            }] }
];
/** @nocollapse */
GridHelperComponent.ctorParameters = () => [
    { type: RendererService }
];
GridHelperComponent.propDecorators = {
    size: [{ type: Input }],
    divisions: [{ type: Input }]
};
if (false) {
    /** @type {?} */
    GridHelperComponent.prototype.size;
    /** @type {?} */
    GridHelperComponent.prototype.divisions;
    /**
     * @type {?}
     * @protected
     */
    GridHelperComponent.prototype.rendererService;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class AtftHelperModule {
}
AtftHelperModule.decorators = [
    { type: NgModule, args: [{
                declarations: [
                    AxesHelperComponent,
                    EmptyComponent,
                    GridHelperComponent
                ],
                imports: [
                    CommonModule
                ],
                exports: [
                    AxesHelperComponent,
                    EmptyComponent,
                    GridHelperComponent
                ]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Creates material
 *
 * @param {?} materialColor color
 * @param {?=} materialName material label as string
 * @param {?=} depthWrite enable depth write
 * @return {?}
 */
function appliedMaterial(materialColor, materialName, depthWrite) {
    /** @type {?} */
    const props = {
        color: (materialColor instanceof Color ? materialColor : appliedColor(materialColor)),
        side: DoubleSide,
        depthWrite: (depthWrite !== undefined ? depthWrite : true)
    };
    if (materialName === 'lamb') {
        return new MeshLambertMaterial(props);
    }
    else if (materialName === 'basic') {
        return new MeshBasicMaterial(props);
    }
    else {
        return new MeshPhongMaterial(props);
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} group
 * @return {?}
 */
function calculateSize(group) {
    /** @type {?} */
    const box = new Box3().setFromObject(group);
    return new Vector3(box.max.x - box.min.x, box.max.y - box.min.y, box.max.z - box.min.z);
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} group
 * @return {?}
 */
function fixCenter(group) {
    /** @type {?} */
    const box = calculateSize(group);
    group.translateX(-box.x / 2);
    group.translateY(-box.y / 2);
    group.translateZ(-box.z / 2);
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} group
 * @param {?} max
 * @return {?}
 */
function scaleToFit(group, max) {
    /** @type {?} */
    const box = calculateSize(group);
    /** @type {?} */
    const scaleX = max.x / box.x;
    /** @type {?} */
    const scaleY = max.y / box.y;
    /** @type {?} */
    const scaleZ = max.z / box.z;
    group.scale.set((scaleX < 1 ? scaleX : 1), (scaleY < 1 ? scaleY : 1), (scaleZ < 1 ? scaleZ : 1));
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class PointLightComponent extends AbstractObject3D {
    /**
     * @param {?} rendererService
     */
    constructor(rendererService) {
        super(rendererService);
        this.rendererService = rendererService;
        this.color = 0xffffff;
        this.intensity = 1;
        this.distance = 500;
        this.castShadow = false;
    }
    /**
     * @protected
     * @return {?}
     */
    newObject3DInstance() {
        /** @type {?} */
        const light = new PointLight(appliedColor(this.color), this.intensity, this.distance);
        if (this.castShadow === true) {
            light.castShadow = this.castShadow;
            // TODO: props
            light.shadow.mapSize.width = 1024;
            light.shadow.mapSize.height = 1024;
            light.shadow.camera.near = 0.5;
            light.shadow.camera.far = 500;
            light.shadow.bias = -0.001;
            light.shadow.radius = 1;
        }
        return light;
    }
}
PointLightComponent.decorators = [
    { type: Component, args: [{
                selector: 'atft-point-light',
                providers: [{ provide: AbstractObject3D, useExisting: forwardRef((/**
                         * @return {?}
                         */
                        () => PointLightComponent)) }],
                template: '<ng-content></ng-content>'
            }] }
];
/** @nocollapse */
PointLightComponent.ctorParameters = () => [
    { type: RendererService }
];
PointLightComponent.propDecorators = {
    color: [{ type: Input }],
    intensity: [{ type: Input }],
    distance: [{ type: Input }],
    castShadow: [{ type: Input }]
};
if (false) {
    /** @type {?} */
    PointLightComponent.prototype.color;
    /** @type {?} */
    PointLightComponent.prototype.intensity;
    /** @type {?} */
    PointLightComponent.prototype.distance;
    /** @type {?} */
    PointLightComponent.prototype.castShadow;
    /**
     * @type {?}
     * @protected
     */
    PointLightComponent.prototype.rendererService;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class HemisphereLightComponent extends AbstractObject3D {
    /**
     * @param {?} rendererService
     */
    constructor(rendererService) {
        super(rendererService);
        this.rendererService = rendererService;
        this.skyColor = 0xffffff;
        this.groundColor = 0x444444;
        this.intensity = 1;
    }
    /**
     * @protected
     * @return {?}
     */
    newObject3DInstance() {
        /** @type {?} */
        const light = new HemisphereLight(appliedColor(this.skyColor), appliedColor(this.groundColor), appliedColor(this.intensity));
        return light;
    }
}
HemisphereLightComponent.decorators = [
    { type: Component, args: [{
                selector: 'atft-hemisphere-light',
                providers: [{ provide: AbstractObject3D, useExisting: forwardRef((/**
                         * @return {?}
                         */
                        () => HemisphereLightComponent)) }],
                template: '<ng-content></ng-content>'
            }] }
];
/** @nocollapse */
HemisphereLightComponent.ctorParameters = () => [
    { type: RendererService }
];
HemisphereLightComponent.propDecorators = {
    skyColor: [{ type: Input }],
    groundColor: [{ type: Input }],
    intensity: [{ type: Input }]
};
if (false) {
    /** @type {?} */
    HemisphereLightComponent.prototype.skyColor;
    /** @type {?} */
    HemisphereLightComponent.prototype.groundColor;
    /** @type {?} */
    HemisphereLightComponent.prototype.intensity;
    /**
     * @type {?}
     * @protected
     */
    HemisphereLightComponent.prototype.rendererService;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class DirectionalLightComponent extends AbstractObject3D {
    /**
     * @param {?} rendererService
     */
    constructor(rendererService) {
        super(rendererService);
        this.rendererService = rendererService;
        this.color = 0xffffff;
        this.intensity = 1;
        // by default, target is 0,0,0
        this.target = new Object3D();
        this.castShadow = true;
    }
    /**
     * @protected
     * @return {?}
     */
    newObject3DInstance() {
        /** @type {?} */
        const light = new DirectionalLight(appliedColor(this.color), this.intensity);
        light.target = this.target;
        if (this.castShadow === true) {
            light.castShadow = this.castShadow;
            // TODO: props
            light.shadow.camera.top = 100;
            light.shadow.camera.bottom = -100;
            light.shadow.camera.left = -100;
            light.shadow.camera.right = 100;
            light.shadow.camera.near = 0.1;
            light.shadow.camera.far = 500;
            light.shadow.mapSize.set(1024, 1024);
            light.shadow.bias = -0.001;
        }
        return light;
    }
}
DirectionalLightComponent.decorators = [
    { type: Component, args: [{
                selector: 'atft-directional-light',
                providers: [{ provide: AbstractObject3D, useExisting: forwardRef((/**
                         * @return {?}
                         */
                        () => DirectionalLightComponent)) }],
                template: '<ng-content></ng-content>'
            }] }
];
/** @nocollapse */
DirectionalLightComponent.ctorParameters = () => [
    { type: RendererService }
];
DirectionalLightComponent.propDecorators = {
    color: [{ type: Input }],
    intensity: [{ type: Input }],
    target: [{ type: Input }],
    castShadow: [{ type: Input }]
};
if (false) {
    /** @type {?} */
    DirectionalLightComponent.prototype.color;
    /** @type {?} */
    DirectionalLightComponent.prototype.intensity;
    /** @type {?} */
    DirectionalLightComponent.prototype.target;
    /** @type {?} */
    DirectionalLightComponent.prototype.castShadow;
    /**
     * @type {?}
     * @protected
     */
    DirectionalLightComponent.prototype.rendererService;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class AtftLightModule {
}
AtftLightModule.decorators = [
    { type: NgModule, args: [{
                declarations: [
                    DirectionalLightComponent,
                    HemisphereLightComponent,
                    PointLightComponent
                ],
                imports: [
                    CommonModule
                ],
                exports: [
                    DirectionalLightComponent,
                    HemisphereLightComponent,
                    PointLightComponent
                ]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @abstract
 */
class AbstractLazyObject3D extends AbstractObject3D {
    constructor() {
        super(...arguments);
        /**
         * Flag to signal whether the parent class instance AbstractObject3D called the
         * overwritten method {\@link AbstractModelLoader#afterInit} yet.
         *
         * Unless that method was called, no methods and properties of {\@link AbstractObject3D}
         * may be safely accessed, especially {\@link AbstractObject3D#addChild} and
         * {\@link AbstractObject3D.renderer}.
         */
        this.parentInitialized = false;
    }
    /**
     * @protected
     * @return {?}
     */
    afterInit() {
        super.afterInit();
        this.parentInitialized = true;
        this.startLoading();
    }
    /**
     * @protected
     * @return {?}
     */
    startLoading() {
        // console.log('AbstractLazyObject3D.startLoading');
        // Trigger model acquisition now that the parent has been initialized.
        this.loadLazyObject().then((/**
         * @param {?} obj
         * @return {?}
         */
        obj => {
            // console.log('AbstractLazyObject3D loaded');
            // remove old if exists
            if (this.lazyObject) {
                super.removeChild(this.lazyObject);
            }
            // add lazy object to scene
            this.lazyObject = obj;
            super.addChild(obj);
            this.rendererService.render();
        })).catch((/**
         * @param {?} err
         * @return {?}
         */
        err => {
            console.error(err);
        }));
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        if (this.lazyObject) {
            super.removeChild(this.lazyObject);
        }
    }
    /**
     * @protected
     * @return {?}
     */
    newObject3DInstance() {
        // Just empty object (holder of lazy object)
        return new Object3D();
    }
}
if (false) {
    /**
     * Flag to signal whether the parent class instance AbstractObject3D called the
     * overwritten method {\@link AbstractModelLoader#afterInit} yet.
     *
     * Unless that method was called, no methods and properties of {\@link AbstractObject3D}
     * may be safely accessed, especially {\@link AbstractObject3D#addChild} and
     * {\@link AbstractObject3D.renderer}.
     * @type {?}
     * @private
     */
    AbstractLazyObject3D.prototype.parentInitialized;
    /**
     * This is reference to lazy loaded Object3D (async after init)
     * @type {?}
     * @protected
     */
    AbstractLazyObject3D.prototype.lazyObject;
    /**
     * Abstract method for lazy loading
     *
     * @abstract
     * @protected
     * @return {?}
     */
    AbstractLazyObject3D.prototype.loadLazyObject = function () { };
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Helper parent class for model loader.
 *
 * @see ObjLoaderComponent
 * @abstract
 */
class AbstractModelLoader extends AbstractLazyObject3D {
    /**
     * The model data source (usually a URI).
     * Settings this property only hides the previous model upon successful
     * loading of the new one. This especially means that if the new data source
     * is invalid, the old model will *not* be removed from the scene.
     * @param {?} newModelUrl
     * @return {?}
     */
    set model(newModelUrl) {
        if (this._model !== newModelUrl) {
            this._model = newModelUrl;
            super.startLoading();
        }
    }
    /**
     * The current model data source (usually a URI).
     * @return {?}
     */
    get model() {
        return this._model;
    }
}
AbstractModelLoader.propDecorators = {
    model: [{ type: Input }]
};
if (false) {
    /**
     * @type {?}
     * @protected
     */
    AbstractModelLoader.prototype._model;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ObjectLoaderComponent extends AbstractModelLoader {
    /**
     * @param {?} rendererService
     */
    constructor(rendererService) {
        super(rendererService);
        this.rendererService = rendererService;
        this.loader = new ObjectLoader();
    }
    /**
     * @protected
     * @return {?}
     */
    loadLazyObject() {
        return __awaiter(this, void 0, void 0, /** @this {!ObjectLoaderComponent} */ function* () {
            // console.log('ObjectLoaderComponent.loadLazyObject');
            return new Promise((/**
             * @param {?} resolve
             * @param {?} reject
             * @return {?}
             */
            (resolve, reject) => {
                this.loader.load(this.model, (/**
                 * @param {?} model
                 * @return {?}
                 */
                model => {
                    // BUG #95: it seems that some textures loaded after last render (and model has black texture instead)
                    resolve(model);
                }), undefined, reject);
            }));
        });
    }
}
ObjectLoaderComponent.decorators = [
    { type: Component, args: [{
                selector: 'atft-object-loader',
                providers: [{ provide: AbstractObject3D, useExisting: forwardRef((/**
                         * @return {?}
                         */
                        () => ObjectLoaderComponent)) }],
                template: '<ng-content></ng-content>'
            }] }
];
/** @nocollapse */
ObjectLoaderComponent.ctorParameters = () => [
    { type: RendererService }
];
if (false) {
    /**
     * @type {?}
     * @private
     */
    ObjectLoaderComponent.prototype.loader;
    /**
     * @type {?}
     * @protected
     */
    ObjectLoaderComponent.prototype.rendererService;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Component for employing THREE.OBJLoader to load [Wavefront *.obj files][1].
 *
 * [1]: https://en.wikipedia.org/wiki/Wavefront_.obj_file
 */
class ObjLoaderComponent extends AbstractModelLoader {
    /**
     * @param {?} rendererService
     */
    constructor(rendererService) {
        super(rendererService);
        this.rendererService = rendererService;
        this.loader = new OBJLoader();
        this.mtlLoader = new MTLLoader();
    }
    /**
     * Path relative to which resources and textures within the loaded obj file are loaded.
     * @deprecated Rather use resourcePath
     * @param {?} newTexturePath
     * @return {?}
     */
    set texturePath(newTexturePath) {
        this.resourcePath = newTexturePath;
    }
    /**
     * @protected
     * @return {?}
     */
    loadLazyObject() {
        return __awaiter(this, void 0, void 0, /** @this {!ObjLoaderComponent} */ function* () {
            // Preloading step for the material
            /** @type {?} */
            const preloadingStep = new Promise((/**
             * @param {?} resolve
             * @param {?} reject
             * @return {?}
             */
            (resolve, reject) => {
                if (this.material === undefined) {
                    // No preloading necessary
                    resolve();
                }
                else {
                    // TODO: If typings of mtlLoader are included in the Three.js NPM
                    // package, remove this 'any' cast.
                    ((/** @type {?} */ (this.mtlLoader))).setResourcePath(this.resourcePath);
                    this.mtlLoader.load(this.material, (/**
                     * @param {?} materialCreator
                     * @return {?}
                     */
                    materialCreator => {
                        materialCreator.preload();
                        this.loader.setMaterials(materialCreator);
                        resolve();
                    }), undefined, reject);
                }
            }));
            // Await preloading and load final model
            return preloadingStep.then((/**
             * @return {?}
             */
            () => {
                return new Promise((/**
                 * @param {?} resolve
                 * @param {?} reject
                 * @return {?}
                 */
                (resolve, reject) => {
                    this.loader.load(this.model, (/**
                     * @param {?} model
                     * @return {?}
                     */
                    model => {
                        resolve(model);
                    }), undefined, reject);
                }));
            }));
        });
    }
}
ObjLoaderComponent.decorators = [
    { type: Component, args: [{
                selector: 'atft-obj-loader',
                providers: [{ provide: AbstractObject3D, useExisting: forwardRef((/**
                         * @return {?}
                         */
                        () => ObjLoaderComponent)) }],
                template: '<ng-content></ng-content>'
            }] }
];
/** @nocollapse */
ObjLoaderComponent.ctorParameters = () => [
    { type: RendererService }
];
ObjLoaderComponent.propDecorators = {
    material: [{ type: Input }],
    texturePath: [{ type: Input }],
    resourcePath: [{ type: Input }]
};
if (false) {
    /**
     * @type {?}
     * @private
     */
    ObjLoaderComponent.prototype.loader;
    /**
     * @type {?}
     * @private
     */
    ObjLoaderComponent.prototype.mtlLoader;
    /** @type {?} */
    ObjLoaderComponent.prototype.material;
    /**
     * Path relative to which resources and textures within the loaded obj file are loaded.
     * @type {?}
     */
    ObjLoaderComponent.prototype.resourcePath;
    /**
     * @type {?}
     * @protected
     */
    ObjLoaderComponent.prototype.rendererService;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class SVGLoaderComponent extends AbstractModelLoader {
    /**
     * @param {?} rendererService
     */
    constructor(rendererService) {
        super(rendererService);
        this.rendererService = rendererService;
        this._overrideMaterialColor = undefined;
        this.material = 'basic';
        this.depthWrite = true;
        this.centered = true;
        this.loader = new SVGLoader();
    }
    /**
     * @return {?}
     */
    get overrideMaterialColor() {
        return this._overrideMaterialColor;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set overrideMaterialColor(value) {
        this._overrideMaterialColor = value;
        this.startLoading();
    }
    /**
     * @protected
     * @return {?}
     */
    loadLazyObject() {
        return __awaiter(this, void 0, void 0, /** @this {!SVGLoaderComponent} */ function* () {
            // console.log('ObjectLoaderComponent.loadLazyObject');
            return new Promise((/**
             * @param {?} resolve
             * @param {?} reject
             * @return {?}
             */
            (resolve, reject) => {
                this.loader.load(this.model, (/**
                 * @param {?} data
                 * @return {?}
                 */
                data => {
                    /** @type {?} */
                    const paths = data.paths;
                    /** @type {?} */
                    const group = new Group();
                    for (let i = 0; i < paths.length; i++) {
                        // NOTE: It seems that ShapePath does not includes typed color, cast to any as workaround
                        /** @type {?} */
                        const path = paths[i];
                        /** @type {?} */
                        const color = (this._overrideMaterialColor ? appliedColor(this._overrideMaterialColor) : path.color);
                        /** @type {?} */
                        const material = appliedMaterial(color, this.material, this.depthWrite);
                        /** @type {?} */
                        const shapes = path.toShapes(true, {});
                        for (let j = 0; j < shapes.length; j++) {
                            /** @type {?} */
                            const shape = shapes[j];
                            /** @type {?} */
                            const geometry = new ShapeBufferGeometry(shape);
                            /** @type {?} */
                            const mesh = new Mesh(geometry, material);
                            group.add(mesh);
                        }
                    }
                    if (this.maxX || this.maxY) {
                        scaleToFit(group, new Vector3(this.maxX, this.maxY, 0));
                    }
                    if (this.centered) {
                        fixCenter(group);
                    }
                    resolve(group);
                }), undefined, reject);
            }));
        });
    }
}
SVGLoaderComponent.decorators = [
    { type: Component, args: [{
                selector: 'atft-svg-loader',
                providers: [{ provide: AbstractObject3D, useExisting: forwardRef((/**
                         * @return {?}
                         */
                        () => SVGLoaderComponent)) }],
                template: '<ng-content></ng-content>'
            }] }
];
/** @nocollapse */
SVGLoaderComponent.ctorParameters = () => [
    { type: RendererService }
];
SVGLoaderComponent.propDecorators = {
    overrideMaterialColor: [{ type: Input }],
    material: [{ type: Input }],
    depthWrite: [{ type: Input }],
    maxX: [{ type: Input }],
    maxY: [{ type: Input }],
    centered: [{ type: Input }]
};
if (false) {
    /**
     * @type {?}
     * @private
     */
    SVGLoaderComponent.prototype._overrideMaterialColor;
    /** @type {?} */
    SVGLoaderComponent.prototype.material;
    /** @type {?} */
    SVGLoaderComponent.prototype.depthWrite;
    /** @type {?} */
    SVGLoaderComponent.prototype.maxX;
    /** @type {?} */
    SVGLoaderComponent.prototype.maxY;
    /** @type {?} */
    SVGLoaderComponent.prototype.centered;
    /**
     * @type {?}
     * @private
     */
    SVGLoaderComponent.prototype.loader;
    /**
     * @type {?}
     * @protected
     */
    SVGLoaderComponent.prototype.rendererService;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class AtftLoaderModule {
}
AtftLoaderModule.decorators = [
    { type: NgModule, args: [{
                declarations: [
                    ObjLoaderComponent,
                    ObjectLoaderComponent,
                    SVGLoaderComponent
                ],
                imports: [
                    CommonModule
                ],
                exports: [
                    ObjLoaderComponent,
                    ObjectLoaderComponent,
                    SVGLoaderComponent
                ]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @abstract
 */
class AbstractMesh extends AbstractObject3D {
    constructor() {
        super(...arguments);
        this.materialColor = 0x5DADE2;
        this.castShadow = true;
        this.receiveShadow = true;
        this.depthWrite = true;
    }
    /**
     * @protected
     * @return {?}
     */
    getMaterial() {
        return appliedMaterial(this.materialColor, this.material, this.depthWrite);
    }
    /**
     * @protected
     * @param {?} mesh
     * @return {?}
     */
    applyShadowProps(mesh) {
        mesh.castShadow = this.castShadow;
        mesh.receiveShadow = this.receiveShadow;
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        super.ngOnChanges(changes);
        if (!this.getObject()) {
            return;
        }
        /** @type {?} */
        let mustRerender = false;
        if (['material', 'materialColor', 'depthWrite'].some((/**
         * @param {?} propName
         * @return {?}
         */
        propName => propName in changes))) {
            this.applyMaterial();
            mustRerender = true;
        }
        if (mustRerender) {
            this.rendererService.render();
        }
    }
    /**
     * @return {?}
     */
    applyMaterial() {
        this.getObject().material = this.getMaterial();
    }
}
AbstractMesh.propDecorators = {
    material: [{ type: Input }],
    materialColor: [{ type: Input }],
    castShadow: [{ type: Input }],
    receiveShadow: [{ type: Input }],
    depthWrite: [{ type: Input }]
};
if (false) {
    /** @type {?} */
    AbstractMesh.prototype.material;
    /** @type {?} */
    AbstractMesh.prototype.materialColor;
    /** @type {?} */
    AbstractMesh.prototype.castShadow;
    /** @type {?} */
    AbstractMesh.prototype.receiveShadow;
    /** @type {?} */
    AbstractMesh.prototype.depthWrite;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class BoxMeshComponent extends AbstractMesh {
    /**
     * @param {?} rendererService
     */
    constructor(rendererService) {
        super(rendererService);
        this.rendererService = rendererService;
        /**
         * Width; that is, the length of the edges parallel to the X axis. Optional; defaults to 1.
         */
        this.width = 1.0;
        /**
         * Height; that is, the length of the edges parallel to the Y axis. Optional; defaults to 1.
         */
        this.height = 1.0;
        /**
         * Depth; that is, the length of the edges parallel to the Z axis. Optional; defaults to 1.
         */
        this.depth = 1.0;
        /**
         * Number of segmented rectangular faces along the width of the sides. Optional; defaults to 1.
         */
        this.widthSegments = 1;
        /**
         * Number of segmented rectangular faces along the height of the sides. Optional; defaults to 1.
         */
        this.heightSegments = 1;
        /**
         * Number of segmented rectangular faces along the depth of the sides. Optional; defaults to 1.
         */
        this.depthSegments = 1;
    }
    /**
     * @protected
     * @return {?}
     */
    newObject3DInstance() {
        // console.log('BoxMeshComponent.newObject3DInstance');
        /** @type {?} */
        const geometry = new BoxGeometry(this.width, this.height, this.depth, this.widthSegments, this.heightSegments, this.depthSegments);
        /** @type {?} */
        const material = this.getMaterial();
        /** @type {?} */
        const mesh = new Mesh(geometry, material);
        this.applyShadowProps(mesh);
        return mesh;
    }
}
BoxMeshComponent.decorators = [
    { type: Component, args: [{
                selector: 'atft-box-mesh',
                providers: [{ provide: AbstractObject3D, useExisting: forwardRef((/**
                         * @return {?}
                         */
                        () => BoxMeshComponent)) }],
                template: '<ng-content></ng-content>'
            }] }
];
/** @nocollapse */
BoxMeshComponent.ctorParameters = () => [
    { type: RendererService }
];
BoxMeshComponent.propDecorators = {
    width: [{ type: Input }],
    height: [{ type: Input }],
    depth: [{ type: Input }],
    widthSegments: [{ type: Input }],
    heightSegments: [{ type: Input }],
    depthSegments: [{ type: Input }]
};
if (false) {
    /**
     * Width; that is, the length of the edges parallel to the X axis. Optional; defaults to 1.
     * @type {?}
     */
    BoxMeshComponent.prototype.width;
    /**
     * Height; that is, the length of the edges parallel to the Y axis. Optional; defaults to 1.
     * @type {?}
     */
    BoxMeshComponent.prototype.height;
    /**
     * Depth; that is, the length of the edges parallel to the Z axis. Optional; defaults to 1.
     * @type {?}
     */
    BoxMeshComponent.prototype.depth;
    /**
     * Number of segmented rectangular faces along the width of the sides. Optional; defaults to 1.
     * @type {?}
     */
    BoxMeshComponent.prototype.widthSegments;
    /**
     * Number of segmented rectangular faces along the height of the sides. Optional; defaults to 1.
     * @type {?}
     */
    BoxMeshComponent.prototype.heightSegments;
    /**
     * Number of segmented rectangular faces along the depth of the sides. Optional; defaults to 1.
     * @type {?}
     */
    BoxMeshComponent.prototype.depthSegments;
    /**
     * @type {?}
     * @protected
     */
    BoxMeshComponent.prototype.rendererService;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class CylinderMeshComponent extends AbstractMesh {
    /**
     * @param {?} rendererService
     */
    constructor(rendererService) {
        super(rendererService);
        this.rendererService = rendererService;
        this.radiusTop = 1.0;
        this.radiusBottom = 1.0;
        this.height = 1.0;
        this.radialSegments = 8;
        this.heightSegments = 1;
        this.openEnded = false;
        this.thetaStart = 0.0;
        this.thetaLength = 2 * Math.PI;
        // console.log('CylinderMeshComponent.constructor');
    }
    /**
     * @protected
     * @return {?}
     */
    newObject3DInstance() {
        // console.log('CylinderMeshComponent.newObject3DInstance');
        /** @type {?} */
        const geometry = new CylinderGeometry(this.radiusTop, this.radiusBottom, this.height, this.radialSegments, this.heightSegments, this.openEnded, this.thetaStart, this.thetaLength);
        /** @type {?} */
        const material = this.getMaterial();
        /** @type {?} */
        const mesh = new Mesh(geometry, material);
        this.applyShadowProps(mesh);
        return mesh;
    }
}
CylinderMeshComponent.decorators = [
    { type: Component, args: [{
                selector: 'atft-cylinder-mesh',
                providers: [{ provide: AbstractObject3D, useExisting: forwardRef((/**
                         * @return {?}
                         */
                        () => CylinderMeshComponent)) }],
                template: '<ng-content></ng-content>'
            }] }
];
/** @nocollapse */
CylinderMeshComponent.ctorParameters = () => [
    { type: RendererService }
];
CylinderMeshComponent.propDecorators = {
    radiusTop: [{ type: Input }],
    radiusBottom: [{ type: Input }],
    height: [{ type: Input }],
    radialSegments: [{ type: Input }],
    heightSegments: [{ type: Input }],
    openEnded: [{ type: Input }],
    thetaStart: [{ type: Input }],
    thetaLength: [{ type: Input }]
};
if (false) {
    /** @type {?} */
    CylinderMeshComponent.prototype.radiusTop;
    /** @type {?} */
    CylinderMeshComponent.prototype.radiusBottom;
    /** @type {?} */
    CylinderMeshComponent.prototype.height;
    /** @type {?} */
    CylinderMeshComponent.prototype.radialSegments;
    /** @type {?} */
    CylinderMeshComponent.prototype.heightSegments;
    /** @type {?} */
    CylinderMeshComponent.prototype.openEnded;
    /** @type {?} */
    CylinderMeshComponent.prototype.thetaStart;
    /** @type {?} */
    CylinderMeshComponent.prototype.thetaLength;
    /**
     * @type {?}
     * @protected
     */
    CylinderMeshComponent.prototype.rendererService;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FrameMeshComponent extends AbstractMesh {
    /**
     * @param {?} rendererService
     */
    constructor(rendererService) {
        super(rendererService);
        this.rendererService = rendererService;
        this.thickness = 2;
        this.sizeX = 20;
        this.sizeY = 20;
    }
    /**
     * @protected
     * @return {?}
     */
    newObject3DInstance() {
        /** @type {?} */
        const halfX = this.sizeX / 2.0;
        /** @type {?} */
        const halfY = this.sizeY / 2.0;
        /** @type {?} */
        const t = this.thickness;
        /** @type {?} */
        const shape = new Shape();
        shape.moveTo(-halfX, halfY);
        shape.lineTo(-halfX - t, halfY + t);
        shape.lineTo(halfX + t, halfY + t);
        shape.lineTo(halfX + t, -halfY - t);
        shape.lineTo(-halfX - t, -halfY - t);
        shape.lineTo(-halfX - t, halfY + t);
        shape.lineTo(-halfX, halfY);
        shape.lineTo(-halfX, -halfY);
        shape.lineTo(halfX, -halfY);
        shape.lineTo(halfX, halfY);
        shape.lineTo(-halfX, halfY);
        /** @type {?} */
        const geometry = new ShapeBufferGeometry(shape);
        /** @type {?} */
        const material = this.getMaterial();
        /** @type {?} */
        const mesh = new Mesh(geometry, material);
        this.applyShadowProps(mesh);
        return mesh;
    }
}
FrameMeshComponent.decorators = [
    { type: Component, args: [{
                selector: 'atft-frame-mesh',
                providers: [{ provide: AbstractObject3D, useExisting: forwardRef((/**
                         * @return {?}
                         */
                        () => FrameMeshComponent)) }],
                template: '<ng-content></ng-content>'
            }] }
];
/** @nocollapse */
FrameMeshComponent.ctorParameters = () => [
    { type: RendererService }
];
FrameMeshComponent.propDecorators = {
    thickness: [{ type: Input }],
    sizeX: [{ type: Input }],
    sizeY: [{ type: Input }]
};
if (false) {
    /** @type {?} */
    FrameMeshComponent.prototype.thickness;
    /** @type {?} */
    FrameMeshComponent.prototype.sizeX;
    /** @type {?} */
    FrameMeshComponent.prototype.sizeY;
    /**
     * @type {?}
     * @protected
     */
    FrameMeshComponent.prototype.rendererService;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class PlaneMeshComponent extends AbstractMesh {
    /**
     * @param {?} rendererService
     */
    constructor(rendererService) {
        super(rendererService);
        this.rendererService = rendererService;
        /**
         * Width; that is, the length of the edges parallel to the X axis. Optional; defaults to 1.
         */
        this.width = 1.0;
        /**
         * Height; that is, the length of the edges parallel to the Y axis. Optional; defaults to 1.
         */
        this.height = 1.0;
        /**
         * Number of segmented rectangular faces along the width of the sides. Optional; defaults to 1.
         */
        this.widthSegments = 1;
        /**
         * Number of segmented rectangular faces along the height of the sides. Optional; defaults to 1.
         */
        this.heightSegments = 1;
    }
    /**
     * @protected
     * @return {?}
     */
    newObject3DInstance() {
        /** @type {?} */
        const geometry = new PlaneBufferGeometry(this.width, this.height, this.widthSegments, this.heightSegments);
        /** @type {?} */
        const material = this.getMaterial();
        /** @type {?} */
        const mesh = new Mesh(geometry, material);
        this.applyShadowProps(mesh);
        return mesh;
    }
}
PlaneMeshComponent.decorators = [
    { type: Component, args: [{
                selector: 'atft-plane-mesh',
                providers: [{ provide: AbstractObject3D, useExisting: forwardRef((/**
                         * @return {?}
                         */
                        () => PlaneMeshComponent)) }],
                template: '<ng-content></ng-content>'
            }] }
];
/** @nocollapse */
PlaneMeshComponent.ctorParameters = () => [
    { type: RendererService }
];
PlaneMeshComponent.propDecorators = {
    width: [{ type: Input }],
    height: [{ type: Input }],
    widthSegments: [{ type: Input }],
    heightSegments: [{ type: Input }]
};
if (false) {
    /**
     * Width; that is, the length of the edges parallel to the X axis. Optional; defaults to 1.
     * @type {?}
     */
    PlaneMeshComponent.prototype.width;
    /**
     * Height; that is, the length of the edges parallel to the Y axis. Optional; defaults to 1.
     * @type {?}
     */
    PlaneMeshComponent.prototype.height;
    /**
     * Number of segmented rectangular faces along the width of the sides. Optional; defaults to 1.
     * @type {?}
     */
    PlaneMeshComponent.prototype.widthSegments;
    /**
     * Number of segmented rectangular faces along the height of the sides. Optional; defaults to 1.
     * @type {?}
     */
    PlaneMeshComponent.prototype.heightSegments;
    /**
     * @type {?}
     * @protected
     */
    PlaneMeshComponent.prototype.rendererService;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class SphereMeshComponent extends AbstractMesh {
    /**
     * @param {?} rendererService
     */
    constructor(rendererService) {
        super(rendererService);
        this.rendererService = rendererService;
    }
    /**
     * @protected
     * @return {?}
     */
    newObject3DInstance() {
        // console.log('SphereMeshComponent.newObject3DInstance');
        /** @type {?} */
        const geometry = new SphereGeometry(this.radius, this.widthSegments, this.hightSegments);
        /** @type {?} */
        const material = this.getMaterial();
        /** @type {?} */
        const mesh = new Mesh(geometry, material);
        this.applyShadowProps(mesh);
        return mesh;
    }
}
SphereMeshComponent.decorators = [
    { type: Component, args: [{
                selector: 'atft-sphere-mesh',
                providers: [{ provide: AbstractObject3D, useExisting: forwardRef((/**
                         * @return {?}
                         */
                        () => SphereMeshComponent)) }],
                template: '<ng-content></ng-content>'
            }] }
];
/** @nocollapse */
SphereMeshComponent.ctorParameters = () => [
    { type: RendererService }
];
SphereMeshComponent.propDecorators = {
    radius: [{ type: Input }],
    widthSegments: [{ type: Input }],
    hightSegments: [{ type: Input }]
};
if (false) {
    /** @type {?} */
    SphereMeshComponent.prototype.radius;
    /** @type {?} */
    SphereMeshComponent.prototype.widthSegments;
    /** @type {?} */
    SphereMeshComponent.prototype.hightSegments;
    /**
     * @type {?}
     * @protected
     */
    SphereMeshComponent.prototype.rendererService;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class TorusMeshComponent extends AbstractMesh {
    /**
     * @param {?} rendererService
     */
    constructor(rendererService) {
        super(rendererService);
        this.rendererService = rendererService;
        /**
         * Radius of the torus, from the center of the torus to the center of the tube
         */
        this.radius = 0.4;
        this.radialSegments = 8;
        this.tubularSegments = 6;
        this.arc = Math.PI * 2;
    }
    /**
     * @protected
     * @return {?}
     */
    newObject3DInstance() {
        this.radius *= 1;
        this.tube *= 1;
        this.radialSegments *= 1;
        this.tubularSegments *= 1;
        /** @type {?} */
        const geometry = new TorusGeometry(this.radius, this.tube, this.radialSegments, this.tubularSegments);
        /** @type {?} */
        const material = this.getMaterial();
        /** @type {?} */
        const mesh = new Mesh(geometry, material);
        this.applyShadowProps(mesh);
        return mesh;
    }
}
TorusMeshComponent.decorators = [
    { type: Component, args: [{
                selector: 'atft-torus-mesh',
                providers: [{ provide: AbstractObject3D, useExisting: forwardRef((/**
                         * @return {?}
                         */
                        () => TorusMeshComponent)) }],
                template: '<ng-content></ng-content>'
            }] }
];
/** @nocollapse */
TorusMeshComponent.ctorParameters = () => [
    { type: RendererService }
];
TorusMeshComponent.propDecorators = {
    radius: [{ type: Input }],
    tube: [{ type: Input }],
    radialSegments: [{ type: Input }],
    tubularSegments: [{ type: Input }],
    arc: [{ type: Input }]
};
if (false) {
    /**
     * Radius of the torus, from the center of the torus to the center of the tube
     * @type {?}
     */
    TorusMeshComponent.prototype.radius;
    /**
     * Radius of the tube.
     * @type {?}
     */
    TorusMeshComponent.prototype.tube;
    /** @type {?} */
    TorusMeshComponent.prototype.radialSegments;
    /** @type {?} */
    TorusMeshComponent.prototype.tubularSegments;
    /** @type {?} */
    TorusMeshComponent.prototype.arc;
    /**
     * @type {?}
     * @protected
     */
    TorusMeshComponent.prototype.rendererService;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @abstract
 */
class AbstractCss3dMesh extends AbstractMesh {
    constructor() {
        super(...arguments);
        this.width = 1.0;
        this.height = 1.0;
        // 1280 / 720 = 1.777777778
        this.resolutionX = 1280;
        this.resolutionY = 720;
        this.widthSegments = 1;
        this.heightSegments = 1;
    }
    /**
     * @protected
     * @return {?}
     */
    newObject3DInstance() {
        /** @type {?} */
        const geometry = new PlaneBufferGeometry(this.width, this.height, this.widthSegments, this.heightSegments);
        /** @type {?} */
        const material = this.getMaterial();
        /** @type {?} */
        const mesh = new Mesh(geometry, material);
        this.applyShadowProps(mesh);
        // Create and scale css3d object:
        /** @type {?} */
        const meshSize = calculateSize(mesh);
        /** @type {?} */
        const css3dObject = this.createCss3dObject();
        this.scaleCss3d(css3dObject, meshSize);
        // append to mesh:
        mesh.add(css3dObject);
        return mesh;
    }
    /**
     * @protected
     * @param {?} group
     * @param {?} max
     * @return {?}
     */
    scaleCss3d(group, max) {
        /** @type {?} */
        const box = new Vector3(this.resolutionX, this.resolutionY, 0);
        /** @type {?} */
        const scaleX = max.x / box.x;
        /** @type {?} */
        const scaleY = max.y / box.y;
        /** @type {?} */
        const scaleZ = max.z / box.z;
        group.scale.set((scaleX < 1 ? scaleX : 1), (scaleY < 1 ? scaleY : 1), (scaleZ < 1 ? scaleZ : 1));
    }
    /**
     * @protected
     * @return {?}
     */
    getMaterial() {
        // TODO: Renderer clear color
        /** @type {?} */
        const transparentMaterial = new MeshBasicMaterial({
            color: 0x000000,
            opacity: 0,
            side: DoubleSide
        });
        return transparentMaterial;
    }
}
AbstractCss3dMesh.propDecorators = {
    width: [{ type: Input }],
    height: [{ type: Input }],
    resolutionX: [{ type: Input }],
    resolutionY: [{ type: Input }]
};
if (false) {
    /** @type {?} */
    AbstractCss3dMesh.prototype.width;
    /** @type {?} */
    AbstractCss3dMesh.prototype.height;
    /** @type {?} */
    AbstractCss3dMesh.prototype.resolutionX;
    /** @type {?} */
    AbstractCss3dMesh.prototype.resolutionY;
    /**
     * @type {?}
     * @private
     */
    AbstractCss3dMesh.prototype.widthSegments;
    /**
     * @type {?}
     * @private
     */
    AbstractCss3dMesh.prototype.heightSegments;
    /**
     * @abstract
     * @protected
     * @return {?}
     */
    AbstractCss3dMesh.prototype.createCss3dObject = function () { };
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class Css3dVideoMeshComponent extends AbstractCss3dMesh {
    /**
     * @param {?} rendererService
     */
    constructor(rendererService) {
        super(rendererService);
        this.rendererService = rendererService;
        this.video = document.createElement('video');
    }
    /**
     * @protected
     * @return {?}
     */
    createCss3dObject() {
        // 1. Create DIV
        /** @type {?} */
        const div = document.createElement('div');
        div.style.width = this.resolutionX + 'px';
        div.style.height = this.resolutionY + 'px';
        div.style.backgroundColor = '#000000';
        div.id = 'myWrapper';
        // 2. Create Video Player with source
        this.video.autoplay = false;
        this.video.loop = true;
        this.video.muted = true;
        /** @type {?} */
        const source = document.createElement('source');
        source.src = this.videoSrc;
        source.type = 'video/mp4';
        this.video.appendChild(source);
        div.appendChild(this.video);
        // 3. Create CSS3DObject
        /** @type {?} */
        const object = new CSS3DObject(div);
        return object;
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        super.ngAfterViewInit();
        this.video.load();
        this.video.addEventListener('canplay', (/**
         * @return {?}
         */
        () => {
            console.log('EVENT');
            this.video.play();
        }));
    }
}
Css3dVideoMeshComponent.decorators = [
    { type: Component, args: [{
                selector: 'atft-css3d-video-mesh',
                providers: [{ provide: AbstractObject3D, useExisting: forwardRef((/**
                         * @return {?}
                         */
                        () => Css3dVideoMeshComponent)) }],
                template: '<ng-content></ng-content>'
            }] }
];
/** @nocollapse */
Css3dVideoMeshComponent.ctorParameters = () => [
    { type: RendererService }
];
Css3dVideoMeshComponent.propDecorators = {
    videoSrc: [{ type: Input }]
};
if (false) {
    /** @type {?} */
    Css3dVideoMeshComponent.prototype.videoSrc;
    /** @type {?} */
    Css3dVideoMeshComponent.prototype.video;
    /**
     * @type {?}
     * @protected
     */
    Css3dVideoMeshComponent.prototype.rendererService;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class AtftMeshModule {
}
AtftMeshModule.decorators = [
    { type: NgModule, args: [{
                declarations: [
                    BoxMeshComponent,
                    CylinderMeshComponent,
                    FrameMeshComponent,
                    PlaneMeshComponent,
                    SphereMeshComponent,
                    TorusMeshComponent,
                    Css3dVideoMeshComponent
                ],
                imports: [
                    CommonModule
                ],
                exports: [
                    BoxMeshComponent,
                    CylinderMeshComponent,
                    FrameMeshComponent,
                    PlaneMeshComponent,
                    SphereMeshComponent,
                    TorusMeshComponent,
                    Css3dVideoMeshComponent
                ]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class TextMeshComponent extends AbstractLazyObject3D {
    /**
     * @param {?} rendererService
     */
    constructor(rendererService) {
        super(rendererService);
        this.rendererService = rendererService;
        this.material = 'basic';
        this._materialColor = 0xDADADA;
        this._text = 'Text';
        this.size = 10;
        this.height = 0.3;
        this.curveSegments = 2;
        this.bevelEnabled = false;
        this.bevelThickness = 0.1;
        this.bevelSize = 0.1;
        this.bevelOffset = 0;
        this.bevelSegments = 1;
        this.fontUrl = './assets/font/helvetiker_regular.typeface.json';
        this.castShadow = true;
        this.receiveShadow = true;
        this.depthWrite = true;
        this.centered = true;
    }
    /**
     * @param {?} materialColor
     * @return {?}
     */
    set materialColor(materialColor) {
        // console.log('change color', materialColor);
        this._materialColor = materialColor;
        this.startLoading();
    }
    /**
     * @return {?}
     */
    get materialColor() {
        return this._materialColor;
    }
    /**
     * @param {?} text
     * @return {?}
     */
    set text(text) {
        this._text = text;
        this.startLoading();
    }
    /**
     * @return {?}
     */
    get text() {
        return this._text;
    }
    /**
     * @return {?}
     */
    getMaterial() {
        return appliedMaterial(this.materialColor, this.material, this.depthWrite);
    }
    /**
     * @protected
     * @return {?}
     */
    loadLazyObject() {
        return __awaiter(this, void 0, void 0, /** @this {!TextMeshComponent} */ function* () {
            // console.log('TextMeshComponent.loadLazyObject');
            return new Promise((/**
             * @param {?} resolve
             * @return {?}
             */
            resolve => {
                /** @type {?} */
                const loader = new FontLoader();
                loader.load(this.fontUrl, (/**
                 * @param {?} font
                 * @return {?}
                 */
                font => {
                    /** @type {?} */
                    const geometry = new TextGeometry(this.text, {
                        font: font,
                        size: this.size,
                        height: this.height,
                        curveSegments: this.curveSegments,
                        bevelEnabled: this.bevelEnabled,
                        bevelThickness: this.bevelThickness,
                        bevelSize: this.bevelSize,
                        bevelOffset: this.bevelOffset,
                        bevelSegments: this.bevelOffset
                    });
                    /** @type {?} */
                    const material = this.getMaterial();
                    /** @type {?} */
                    const mesh = new Mesh(geometry, material);
                    mesh.castShadow = this.castShadow;
                    mesh.receiveShadow = this.receiveShadow;
                    if (this.centered) {
                        fixCenter(mesh);
                    }
                    resolve(mesh);
                }));
            }));
        });
    }
}
TextMeshComponent.decorators = [
    { type: Component, args: [{
                selector: 'atft-text-mesh',
                providers: [{ provide: AbstractObject3D, useExisting: forwardRef((/**
                         * @return {?}
                         */
                        () => TextMeshComponent)) }],
                template: '<ng-content></ng-content>'
            }] }
];
/** @nocollapse */
TextMeshComponent.ctorParameters = () => [
    { type: RendererService }
];
TextMeshComponent.propDecorators = {
    material: [{ type: Input }],
    materialColor: [{ type: Input }],
    text: [{ type: Input }],
    size: [{ type: Input }],
    height: [{ type: Input }],
    curveSegments: [{ type: Input }],
    bevelEnabled: [{ type: Input }],
    bevelThickness: [{ type: Input }],
    bevelSize: [{ type: Input }],
    bevelOffset: [{ type: Input }],
    bevelSegments: [{ type: Input }],
    fontUrl: [{ type: Input }],
    castShadow: [{ type: Input }],
    receiveShadow: [{ type: Input }],
    depthWrite: [{ type: Input }],
    centered: [{ type: Input }]
};
if (false) {
    /** @type {?} */
    TextMeshComponent.prototype.material;
    /**
     * @type {?}
     * @private
     */
    TextMeshComponent.prototype._materialColor;
    /**
     * @type {?}
     * @private
     */
    TextMeshComponent.prototype._text;
    /** @type {?} */
    TextMeshComponent.prototype.size;
    /** @type {?} */
    TextMeshComponent.prototype.height;
    /** @type {?} */
    TextMeshComponent.prototype.curveSegments;
    /** @type {?} */
    TextMeshComponent.prototype.bevelEnabled;
    /** @type {?} */
    TextMeshComponent.prototype.bevelThickness;
    /** @type {?} */
    TextMeshComponent.prototype.bevelSize;
    /** @type {?} */
    TextMeshComponent.prototype.bevelOffset;
    /** @type {?} */
    TextMeshComponent.prototype.bevelSegments;
    /** @type {?} */
    TextMeshComponent.prototype.fontUrl;
    /** @type {?} */
    TextMeshComponent.prototype.castShadow;
    /** @type {?} */
    TextMeshComponent.prototype.receiveShadow;
    /** @type {?} */
    TextMeshComponent.prototype.depthWrite;
    /** @type {?} */
    TextMeshComponent.prototype.centered;
    /**
     * @type {?}
     * @protected
     */
    TextMeshComponent.prototype.rendererService;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class AtftTextModule {
}
AtftTextModule.decorators = [
    { type: NgModule, args: [{
                declarations: [
                    TextMeshComponent
                ],
                imports: [
                    CommonModule
                ],
                exports: [
                    TextMeshComponent
                ]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class SceneComponent extends AbstractObject3D {
    /**
     * @param {?} rendererService
     */
    constructor(rendererService) {
        super(rendererService);
        this.rendererService = rendererService;
        this.background = 0xffffff;
        this.fog = false;
        this.fogColor = 0xa0a0a0;
        this.fogNear = 10;
        this.fogFar = 500;
        // TODO: directive?
        rendererService.setScene(this);
    }
    /**
     * @protected
     * @return {?}
     */
    newObject3DInstance() {
        /** @type {?} */
        const scene = new Scene();
        scene.background = new Color(appliedColor(this.background));
        if (this.fog === true) {
            scene.fog = new Fog(appliedColor(this.fogColor), this.fogNear, this.fogFar);
        }
        return scene;
    }
}
SceneComponent.decorators = [
    { type: Component, args: [{
                selector: 'atft-scene',
                providers: [{ provide: AbstractObject3D, useExisting: forwardRef((/**
                         * @return {?}
                         */
                        () => SceneComponent)) }],
                template: '<ng-content></ng-content>'
            }] }
];
/** @nocollapse */
SceneComponent.ctorParameters = () => [
    { type: RendererService }
];
SceneComponent.propDecorators = {
    background: [{ type: Input }],
    fog: [{ type: Input }],
    fogColor: [{ type: Input }],
    fogNear: [{ type: Input }],
    fogFar: [{ type: Input }]
};
if (false) {
    /** @type {?} */
    SceneComponent.prototype.background;
    /** @type {?} */
    SceneComponent.prototype.fog;
    /** @type {?} */
    SceneComponent.prototype.fogColor;
    /** @type {?} */
    SceneComponent.prototype.fogNear;
    /** @type {?} */
    SceneComponent.prototype.fogFar;
    /**
     * @type {?}
     * @protected
     */
    SceneComponent.prototype.rendererService;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class AtftObjectModule {
}
AtftObjectModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    AtftConnectorModule,
                    AtftHelperModule,
                    AtftLightModule,
                    AtftLoaderModule,
                    AtftMeshModule,
                    AtftTextModule
                ],
                declarations: [
                    SceneComponent
                ],
                exports: [
                    SceneComponent,
                    CommonModule,
                    AtftConnectorModule,
                    AtftHelperModule,
                    AtftLightModule,
                    AtftLoaderModule,
                    AtftMeshModule,
                    AtftTextModule
                ]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class RaycasterService {
    constructor() {
        this.raycaster = new Raycaster();
        this.enabled = false;
        this.groups = [];
        this.paused = false;
        this.onMouseMove = this.onMouseMove.bind(this);
        this.onMouseDown = this.onMouseDown.bind(this);
        this.onTouchStart = this.onTouchStart.bind(this);
        this.subscribe();
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.disable();
        this.unsubscribe();
    }
    /**
     * @private
     * @return {?}
     */
    subscribe() {
        window.addEventListener('mousemove', this.onMouseMove);
        window.addEventListener('mousedown', this.onMouseDown);
        window.addEventListener('touchstart', this.onTouchStart);
    }
    /**
     * @private
     * @return {?}
     */
    unsubscribe() {
        // console.log('unsubscribe raycaster');
        window.removeEventListener('mousemove', this.onMouseMove);
        window.removeEventListener('mousedown', this.onMouseDown);
        window.removeEventListener('touchstart', this.onTouchStart);
    }
    /**
     * @return {?}
     */
    enable() {
        this.enabled = true;
    }
    /**
     * @return {?}
     */
    disable() {
        this.enabled = false;
    }
    /**
     * @return {?}
     */
    pause() {
        this.paused = true;
    }
    /**
     * @return {?}
     */
    resume() {
        this.paused = false;
    }
    /**
     * @return {?}
     */
    get isEnabled() {
        return this.enabled;
    }
    /**
     * @param {?} camera
     * @return {?}
     */
    setCamera(camera) {
        // console.log('Add camera to raycaster', camera);
        this.camera = camera;
    }
    /**
     * @param {?} group
     * @return {?}
     */
    addGroup(group) {
        // console.log('RaycasterService.addGroup', group.name, group);
        this.groups.push(group);
    }
    /**
     * @private
     * @param {?} event
     * @return {?}
     */
    onMouseMove(event) {
        if (!this.isReady()) {
            return;
        }
        event.preventDefault();
        /** @type {?} */
        const i = this.getFirstIntersectedGroup(event.layerX, event.layerY);
        if (!this.selected || this.selected !== i) {
            if (this.selected) {
                this.selected.dispatchEvent({ type: 'mouseExit' });
                this.selected = null;
            }
            if (i) {
                this.selected = i;
                // console.log('RaycasterService.mouseEnter', i);
                this.selected.dispatchEvent({ type: 'mouseEnter' });
            }
        }
    }
    /**
     * @private
     * @param {?} event
     * @return {?}
     */
    onMouseDown(event) {
        if (!this.isReady(true)) {
            return;
        }
        event.preventDefault();
        /** @type {?} */
        const i = this.getFirstIntersectedGroup(event.layerX, event.layerY);
        if (i) {
            i.dispatchEvent({ type: 'mouseDown' });
        }
    }
    /**
     * @private
     * @param {?} event
     * @return {?}
     */
    onTouchStart(event) {
        // console.log(event);
        if (!this.isReady()) {
            return;
        }
        event.preventDefault();
        /** @type {?} */
        const i = this.getFirstIntersectedGroup(event.touches[0].clientX, event.touches[0].clientY);
        if (i) {
            i.dispatchEvent({ type: 'mouseDown' });
        }
    }
    /**
     * @private
     * @param {?=} ignorePaused
     * @return {?}
     */
    isReady(ignorePaused) {
        return this.enabled
            && (ignorePaused || !this.paused)
            && this.camera
            && this.camera.camera
            && this.groups
            && this.groups.length > 0;
    }
    /**
     * @private
     * @param {?} x
     * @param {?} y
     * @return {?}
     */
    getFirstIntersectedGroup(x, y) {
        x = (x / window.innerWidth) * 2 - 1;
        y = -(y / window.innerHeight) * 2 + 1;
        /** @type {?} */
        const mouseVector = new Vector3(x, y, 0.5);
        this.raycaster.setFromCamera(mouseVector, this.camera.camera);
        // loop across all groups. Try to find the group with nearest distance.
        /** @type {?} */
        let nearestIntersection;
        /** @type {?} */
        let nearestGroup;
        for (let k = 0; k < this.groups.length; k++) {
            /** @type {?} */
            const i = this.groups[k].getObject();
            /** @type {?} */
            const intersection = this.raycaster.intersectObject(i, true);
            if (intersection.length > 0 && (!nearestIntersection || nearestIntersection.distance > intersection[0].distance)) {
                nearestIntersection = intersection[0];
                nearestGroup = i;
            }
        }
        // return the group with nearest distance
        if (nearestGroup) {
            return nearestGroup;
        }
        else {
            return;
        }
    }
}
RaycasterService.decorators = [
    { type: Injectable }
];
/** @nocollapse */
RaycasterService.ctorParameters = () => [];
if (false) {
    /**
     * @type {?}
     * @private
     */
    RaycasterService.prototype.raycaster;
    /**
     * @type {?}
     * @private
     */
    RaycasterService.prototype.selected;
    /**
     * @type {?}
     * @private
     */
    RaycasterService.prototype.enabled;
    /**
     * @type {?}
     * @private
     */
    RaycasterService.prototype.camera;
    /**
     * @type {?}
     * @private
     */
    RaycasterService.prototype.groups;
    /**
     * @type {?}
     * @private
     */
    RaycasterService.prototype.paused;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class RendererCanvasComponent {
    /**
     * @param {?} rendererService
     */
    constructor(rendererService) {
        this.rendererService = rendererService;
        // console.log('RendererComponent.constructor');
        this.onResize = this.onResize.bind(this);
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        // console.log('RendererComponent.ngAfterViewInit');
        this.rendererService.initialize(this.canvas);
    }
    /**
     * The render pane on which the scene is rendered.
     * Currently, only the WebGL renderer with a canvas is used in this
     * implementation, so this property will always be an ElementRef to the
     * underlying <canvas> element.
     *
     * \@example This property can be used to restrict the orbit control (i.e. the
     * area which is listened for mouse move and zoom events) to the rendering pane
     * @return {?}
     */
    get renderPane() {
        return this.canvasRef;
    }
    /**
     * @private
     * @return {?}
     */
    get canvas() {
        return this.canvasRef.nativeElement;
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onResize(event) {
        // strange, but single 100% resizing has unexpected behaviour with flex CSS
        // as workaround - resettling to 100 pixels, then to 100%
        this.rendererService.resize(this.canvas, '100px');
        this.rendererService.resize(this.canvas, '100%');
    }
}
RendererCanvasComponent.decorators = [
    { type: Component, args: [{
                selector: 'atft-renderer-canvas',
                template: "<canvas #canvas>\r\n  <ng-content></ng-content>\r\n</canvas>\r\n",
                styles: [":host{display:flex;flex:1}canvas{flex:1}"]
            }] }
];
/** @nocollapse */
RendererCanvasComponent.ctorParameters = () => [
    { type: RendererService }
];
RendererCanvasComponent.propDecorators = {
    canvasRef: [{ type: ViewChild, args: ['canvas', { static: true },] }],
    onResize: [{ type: HostListener, args: ['window:resize', ['$event'],] }]
};
if (false) {
    /**
     * @type {?}
     * @private
     */
    RendererCanvasComponent.prototype.canvasRef;
    /**
     * @type {?}
     * @private
     */
    RendererCanvasComponent.prototype.rendererService;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @abstract
 * @template T
 */
class AbstractOrbitControls {
    /**
     * @param {?} rendererService
     * @param {?} raycasterService
     */
    constructor(rendererService, raycasterService) {
        this.rendererService = rendererService;
        this.raycasterService = raycasterService;
        // console.log('OrbitControlsComponent.constructor');
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        // If the THREE.js OrbitControls are not set up yet, we do not need to update
        // anything as they will pick the new values from the @Input properties automatically
        // upon creation.
        if (!this.controls) {
            return;
        }
        if (changes['listeningControlElement']) {
            // The DOM element the OrbitControls listen on cannot be changed once an
            // OrbitControls object is created. We thus need to recreate it.
            this.controls.dispose();
            this.setUpControls();
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        if (this.controls) {
            this.controls.dispose();
        }
    }
    /**
     * @private
     * @return {?}
     */
    configureListeners() {
        this.controls.addEventListener('change', (/**
         * @return {?}
         */
        () => {
            this.rendererService.render();
        }));
        // don't raycast during rotation/damping/panning
        if (this.raycasterService.isEnabled) {
            this.controls.addEventListener('start', (/**
             * @return {?}
             */
            () => {
                this.raycasterService.pause();
            }));
            this.controls.addEventListener('end', (/**
             * @return {?}
             */
            () => {
                this.raycasterService.resume();
            }));
        }
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        // console.log('OrbitControlsComponent.ngAfterViewInit');
        if (this.childCameras === undefined || this.childCameras.first === undefined) {
            throw new Error('Camera is not found');
        }
        if (!this.webGlRenderer) {
            throw new Error('webGlRenderer is not found');
        }
        this.listeningControlElement = this.webGlRenderer.renderPane;
        this.setUpControls();
        this.configureListeners();
        this.rendererService.render();
    }
}
AbstractOrbitControls.propDecorators = {
    childCameras: [{ type: ContentChildren, args: [AbstractCamera, { descendants: true },] }],
    webGlRenderer: [{ type: ContentChild, args: [RendererCanvasComponent, { static: false },] }]
};
if (false) {
    /** @type {?} */
    AbstractOrbitControls.prototype.childCameras;
    /** @type {?} */
    AbstractOrbitControls.prototype.webGlRenderer;
    /**
     * The element on whose native element the orbit control will listen for mouse events.
     *
     * Note that keyboard events are still listened for on the global window object, this is
     * a known issue from Three.js: https://github.com/mrdoob/three.js/pull/10315
     * @type {?}
     * @protected
     */
    AbstractOrbitControls.prototype.listeningControlElement;
    /**
     * @type {?}
     * @protected
     */
    AbstractOrbitControls.prototype.controls;
    /**
     * @type {?}
     * @protected
     */
    AbstractOrbitControls.prototype.rendererService;
    /**
     * @type {?}
     * @protected
     */
    AbstractOrbitControls.prototype.raycasterService;
    /**
     * @abstract
     * @protected
     * @return {?}
     */
    AbstractOrbitControls.prototype.setUpControls = function () { };
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class OrbitControlsComponent extends AbstractOrbitControls {
    /**
     * @param {?} rendererService
     * @param {?} raycasterService
     */
    constructor(rendererService, raycasterService) {
        super(rendererService, raycasterService);
        this.rendererService = rendererService;
        this.raycasterService = raycasterService;
        this.rotateSpeed = 1.0;
        this.zoomSpeed = 1.2;
    }
    /**
     * @protected
     * @return {?}
     */
    setUpControls() {
        this.controls = new OrbitControls(this.childCameras.first.camera, this.listeningControlElement && this.listeningControlElement.nativeElement);
        this.controls.rotateSpeed = this.rotateSpeed;
        this.controls.zoomSpeed = this.zoomSpeed;
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (!this.controls) {
            return;
        }
        super.ngOnChanges(changes);
        if (changes['rotateSpeed']) {
            this.controls.rotateSpeed = this.rotateSpeed;
        }
        if (changes['zoomSpeed']) {
            this.controls.zoomSpeed = this.zoomSpeed;
        }
    }
}
OrbitControlsComponent.decorators = [
    { type: Component, args: [{
                selector: 'atft-orbit-controls',
                template: `
      <ng-content></ng-content>`,
                styles: [":host{display:flex;flex:1}"]
            }] }
];
/** @nocollapse */
OrbitControlsComponent.ctorParameters = () => [
    { type: RendererService },
    { type: RaycasterService }
];
OrbitControlsComponent.propDecorators = {
    rotateSpeed: [{ type: Input }],
    zoomSpeed: [{ type: Input }]
};
if (false) {
    /** @type {?} */
    OrbitControlsComponent.prototype.rotateSpeed;
    /** @type {?} */
    OrbitControlsComponent.prototype.zoomSpeed;
    /**
     * @type {?}
     * @protected
     */
    OrbitControlsComponent.prototype.rendererService;
    /**
     * @type {?}
     * @protected
     */
    OrbitControlsComponent.prototype.raycasterService;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class MapControlsComponent extends AbstractOrbitControls {
    /**
     * @param {?} rendererService
     * @param {?} raycasterService
     * @param {?} animationService
     */
    constructor(rendererService, raycasterService, animationService) {
        super(rendererService, raycasterService);
        this.rendererService = rendererService;
        this.raycasterService = raycasterService;
        this.animationService = animationService;
        this.rotateSpeed = 1.0;
        this.zoomSpeed = 1.2;
        this.autoRotate = false;
        this.autoRotateSpeed = 0.5;
        this.enableDamping = false;
        this.dampingFactor = 0.1;
        this.screenSpacePanning = false;
        this.minDistance = 20;
        this.maxDistance = 200;
        this.maxPolarAngle = Math.PI / 2 - 0.1;
        this.panSpeed = 1.2;
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (!this.controls) {
            return;
        }
        super.ngOnChanges(changes);
        if (changes['rotateSpeed']) {
            this.controls.rotateSpeed = this.rotateSpeed;
        }
        if (changes['zoomSpeed']) {
            this.controls.zoomSpeed = this.zoomSpeed;
        }
        // TODO: add others
    }
    /**
     * @protected
     * @return {?}
     */
    setUpControls() {
        this.controls = new MapControls(this.childCameras.first.camera, this.listeningControlElement && this.listeningControlElement.nativeElement);
        this.controls.rotateSpeed = this.rotateSpeed;
        this.controls.zoomSpeed = this.zoomSpeed;
        this.controls.panSpeed = this.panSpeed;
        this.controls.autoRotate = this.autoRotate;
        this.controls.autoRotateSpeed = this.autoRotateSpeed;
        this.controls.enableDamping = this.enableDamping; // an animation loop is required when either damping or auto-rotation are enabled
        this.controls.dampingFactor = this.dampingFactor;
        this.controls.screenSpacePanning = this.screenSpacePanning;
        this.controls.minDistance = this.minDistance;
        this.controls.maxDistance = this.maxDistance;
        this.controls.maxPolarAngle = this.maxPolarAngle;
        this.controls.update();
        // Advanced animation:
        if (this.autoRotate || this.enableDamping) {
            this.animationService.animate.subscribe((/**
             * @return {?}
             */
            () => {
                this.controls.update();
            }));
            this.controls.addEventListener('change', (/**
             * @return {?}
             */
            () => {
                this.rendererService.render();
            }));
            this.animationService.start();
        }
        this.rendererService.render();
    }
}
MapControlsComponent.decorators = [
    { type: Component, args: [{
                selector: 'atft-map-controls',
                template: `
      <ng-content></ng-content>`,
                styles: [":host{display:flex;flex:1}"]
            }] }
];
/** @nocollapse */
MapControlsComponent.ctorParameters = () => [
    { type: RendererService },
    { type: RaycasterService },
    { type: AnimationService }
];
MapControlsComponent.propDecorators = {
    rotateSpeed: [{ type: Input }],
    zoomSpeed: [{ type: Input }],
    autoRotate: [{ type: Input }],
    autoRotateSpeed: [{ type: Input }],
    enableDamping: [{ type: Input }],
    dampingFactor: [{ type: Input }],
    screenSpacePanning: [{ type: Input }],
    minDistance: [{ type: Input }],
    maxDistance: [{ type: Input }],
    maxPolarAngle: [{ type: Input }],
    panSpeed: [{ type: Input }]
};
if (false) {
    /** @type {?} */
    MapControlsComponent.prototype.rotateSpeed;
    /** @type {?} */
    MapControlsComponent.prototype.zoomSpeed;
    /** @type {?} */
    MapControlsComponent.prototype.autoRotate;
    /** @type {?} */
    MapControlsComponent.prototype.autoRotateSpeed;
    /** @type {?} */
    MapControlsComponent.prototype.enableDamping;
    /** @type {?} */
    MapControlsComponent.prototype.dampingFactor;
    /** @type {?} */
    MapControlsComponent.prototype.screenSpacePanning;
    /** @type {?} */
    MapControlsComponent.prototype.minDistance;
    /** @type {?} */
    MapControlsComponent.prototype.maxDistance;
    /** @type {?} */
    MapControlsComponent.prototype.maxPolarAngle;
    /** @type {?} */
    MapControlsComponent.prototype.panSpeed;
    /**
     * @type {?}
     * @protected
     */
    MapControlsComponent.prototype.rendererService;
    /**
     * @type {?}
     * @protected
     */
    MapControlsComponent.prototype.raycasterService;
    /**
     * @type {?}
     * @protected
     */
    MapControlsComponent.prototype.animationService;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class AtftControlModule {
}
AtftControlModule.decorators = [
    { type: NgModule, args: [{
                declarations: [
                    OrbitControlsComponent,
                    MapControlsComponent
                ],
                imports: [
                    CommonModule
                ],
                exports: [
                    OrbitControlsComponent,
                    MapControlsComponent
                ]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class Deg2RadPipe {
    /**
     * Converts degrees to radians
     * @param {?} degrees
     * @return {?}
     */
    transform(degrees) {
        return (degrees / 180) * Math.PI;
    }
}
Deg2RadPipe.decorators = [
    { type: Pipe, args: [{
                name: 'deg2rad'
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class Rad2DegPipe {
    /**
     * Converts radians to degrees
     * @param {?} radians Radians
     * @return {?}
     */
    transform(radians) {
        return radians * (180 / Math.PI);
    }
}
Rad2DegPipe.decorators = [
    { type: Pipe, args: [{
                name: 'rad2deg'
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class AtftPipeModule {
}
AtftPipeModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule
                ],
                declarations: [
                    Deg2RadPipe,
                    Rad2DegPipe
                ],
                exports: [
                    Deg2RadPipe,
                    Rad2DegPipe
                ]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class AtftRendererModule {
}
AtftRendererModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule
                ],
                declarations: [
                    RendererCanvasComponent
                ],
                providers: [
                    RendererService
                ],
                exports: [
                    RendererCanvasComponent
                ]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class AtftAnimationModule {
}
AtftAnimationModule.decorators = [
    { type: NgModule, args: [{
                providers: [
                    AnimationService
                ]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Only components marked as atft-raycaster-group emit raycaster events.
 * NOTE: All childs are also considered by raycaster (very usefull, for composite components).
 */
class RaycasterGroupDirective {
    /**
     * @param {?} host
     * @param {?} raycasterService
     */
    constructor(host, raycasterService) {
        this.host = host;
        this.raycasterService = raycasterService;
        this.mouseEnter = new EventEmitter();
        this.mouseExit = new EventEmitter();
        this.mouseDown = new EventEmitter();
        this.onMouseEnter = this.onMouseEnter.bind(this);
        this.onMouseExit = this.onMouseExit.bind(this);
        this.onMouseDown = this.onMouseDown.bind(this);
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        this.raycasterService.addGroup(this.host);
        this.subscribeEvents();
    }
    /**
     * @private
     * @return {?}
     */
    subscribeEvents() {
        /** @type {?} */
        const obj = this.host.getObject();
        obj.addEventListener('mouseEnter', this.onMouseEnter);
        obj.addEventListener('mouseExit', this.onMouseExit);
        obj.addEventListener('mouseDown', this.onMouseDown);
    }
    /**
     * @private
     * @return {?}
     */
    unSubscribeEvents() {
        /** @type {?} */
        const obj = this.host.getObject();
        obj.removeEventListener('mouseEnter', this.onMouseEnter);
        obj.removeEventListener('mouseExit', this.onMouseExit);
        obj.removeEventListener('mouseDown', this.onMouseDown);
    }
    /**
     * @private
     * @return {?}
     */
    onMouseExit() {
        this.mouseExit.emit();
    }
    /**
     * @private
     * @return {?}
     */
    onMouseEnter() {
        this.mouseEnter.emit();
    }
    /**
     * @private
     * @return {?}
     */
    onMouseDown() {
        this.mouseDown.emit();
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.unSubscribeEvents();
    }
}
RaycasterGroupDirective.decorators = [
    { type: Directive, args: [{ selector: '[atft-raycaster-group]' },] }
];
/** @nocollapse */
RaycasterGroupDirective.ctorParameters = () => [
    { type: AbstractObject3D },
    { type: RaycasterService }
];
RaycasterGroupDirective.propDecorators = {
    mouseEnter: [{ type: Output }],
    mouseExit: [{ type: Output }],
    mouseDown: [{ type: Output }]
};
if (false) {
    /** @type {?} */
    RaycasterGroupDirective.prototype.mouseEnter;
    /** @type {?} */
    RaycasterGroupDirective.prototype.mouseExit;
    /** @type {?} */
    RaycasterGroupDirective.prototype.mouseDown;
    /**
     * @type {?}
     * @private
     */
    RaycasterGroupDirective.prototype.host;
    /**
     * @type {?}
     * @private
     */
    RaycasterGroupDirective.prototype.raycasterService;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class RaycasterCameraDirective {
    /**
     * @param {?} host
     * @param {?} raycasterService
     */
    constructor(host, raycasterService) {
        this.host = host;
        this.raycasterService = raycasterService;
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        this.raycasterService.setCamera(this.host);
    }
}
RaycasterCameraDirective.decorators = [
    { type: Directive, args: [{ selector: '[atft-raycaster-camera]' },] }
];
/** @nocollapse */
RaycasterCameraDirective.ctorParameters = () => [
    { type: AbstractCamera },
    { type: RaycasterService }
];
if (false) {
    /**
     * @type {?}
     * @private
     */
    RaycasterCameraDirective.prototype.host;
    /**
     * @type {?}
     * @private
     */
    RaycasterCameraDirective.prototype.raycasterService;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class RaycasterEnableDirective {
    /**
     * @param {?} raycasterService
     */
    constructor(raycasterService) {
        this.raycasterService = raycasterService;
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        this.raycasterService.enable();
    }
}
RaycasterEnableDirective.decorators = [
    { type: Directive, args: [{ selector: '[atft-raycaster-enable]' },] }
];
/** @nocollapse */
RaycasterEnableDirective.ctorParameters = () => [
    { type: RaycasterService }
];
if (false) {
    /**
     * @type {?}
     * @private
     */
    RaycasterEnableDirective.prototype.raycasterService;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class AtftRaycasterModule {
}
AtftRaycasterModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule
                ],
                declarations: [
                    RaycasterGroupDirective,
                    RaycasterCameraDirective,
                    RaycasterEnableDirective
                ],
                providers: [
                    RaycasterService
                ],
                exports: [
                    RaycasterGroupDirective,
                    RaycasterCameraDirective,
                    RaycasterEnableDirective
                ]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// NOTE: In case of "ERROR in Unexpected value 'undefined' exported by the module 'AtftModule" fix imports (do not import index.ts)
class AtftModule {
}
AtftModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    AtftCameraModule,
                    AtftObjectModule,
                    AtftControlModule,
                    AtftPipeModule,
                    AtftRendererModule,
                    AtftAnimationModule,
                    AtftRaycasterModule
                ],
                exports: [
                    AtftCameraModule,
                    AtftObjectModule,
                    AtftControlModule,
                    AtftPipeModule,
                    AtftRendererModule,
                    AtftAnimationModule,
                    AtftRaycasterModule
                ]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @record
 */
function StatsResults() { }
if (false) {
    /** @type {?} */
    StatsResults.prototype.ms;
    /** @type {?} */
    StatsResults.prototype.count;
    /** @type {?} */
    StatsResults.prototype.callsPerSecond;
}
class StatsService {
    constructor() {
        this.ms = 0;
        this.count = 0;
    }
    /**
     * @return {?}
     */
    start() {
        this.lastTime = Date.now();
    }
    /**
     * @return {?}
     */
    end() {
        /** @type {?} */
        const deltaMs = Date.now() - this.lastTime;
        this.ms += deltaMs;
        this.count++;
    }
    /**
     * @return {?}
     */
    getStats() {
        return {
            ms: this.ms,
            count: this.count,
            callsPerSecond: Math.round(this.count / (this.ms / 1000))
        };
    }
    /**
     * @return {?}
     */
    reset() {
        this.ms = 0;
        this.count = 0;
    }
}
StatsService.decorators = [
    { type: Injectable }
];
if (false) {
    /**
     * @type {?}
     * @private
     */
    StatsService.prototype.lastTime;
    /**
     * @type {?}
     * @private
     */
    StatsService.prototype.ms;
    /**
     * @type {?}
     * @private
     */
    StatsService.prototype.count;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { AnimationService, AtftModule, AxesHelperComponent, BoxMeshComponent, Css3dVideoMeshComponent, CylinderMeshComponent, Deg2RadPipe, DirectionalLightComponent, EmptyComponent, FrameMeshComponent, GridHelperComponent, HemisphereLightComponent, LineConnectorComponent, MapControlsComponent, MeshLineConnectorComponent, ObjLoaderComponent, ObjectLoaderComponent, OrbitControlsComponent, PerspectiveCameraComponent, PlaneMeshComponent, PointLightComponent, Rad2DegPipe, RaycasterCameraDirective, RaycasterEnableDirective, RaycasterGroupDirective, RaycasterService, RendererCanvasComponent, RendererService, SVGLoaderComponent, SceneComponent, SphereMeshComponent, StatsService, TorusMeshComponent, appliedColor, appliedMaterial, calculateSize, fixCenter, scaleToFit, AtftCameraModule as ɵa, PerspectiveCameraComponent as ɵb, BoxMeshComponent as ɵba, AbstractMesh as ɵbb, CylinderMeshComponent as ɵbc, FrameMeshComponent as ɵbd, PlaneMeshComponent as ɵbe, SphereMeshComponent as ɵbf, TorusMeshComponent as ɵbg, Css3dVideoMeshComponent as ɵbh, AbstractCss3dMesh as ɵbi, AtftTextModule as ɵbj, TextMeshComponent as ɵbk, SceneComponent as ɵbl, AtftControlModule as ɵbm, OrbitControlsComponent as ɵbn, AbstractOrbitControls as ɵbo, RendererCanvasComponent as ɵbp, RaycasterService as ɵbq, MapControlsComponent as ɵbr, AtftPipeModule as ɵbs, Deg2RadPipe as ɵbt, Rad2DegPipe as ɵbu, AtftRendererModule as ɵbv, AtftAnimationModule as ɵbw, AtftRaycasterModule as ɵbx, RaycasterGroupDirective as ɵby, RaycasterCameraDirective as ɵbz, AbstractCamera as ɵc, RaycasterEnableDirective as ɵca, RendererService as ɵd, AtftObjectModule as ɵe, AtftConnectorModule as ɵf, LineConnectorComponent as ɵg, AbstractConnector as ɵh, AbstractObject3D as ɵi, MeshLineConnectorComponent as ɵj, AnimationService as ɵk, AtftHelperModule as ɵl, AxesHelperComponent as ɵm, EmptyComponent as ɵn, GridHelperComponent as ɵo, AtftLightModule as ɵp, DirectionalLightComponent as ɵq, HemisphereLightComponent as ɵr, PointLightComponent as ɵs, AtftLoaderModule as ɵt, ObjLoaderComponent as ɵu, AbstractModelLoader as ɵv, AbstractLazyObject3D as ɵw, ObjectLoaderComponent as ɵx, SVGLoaderComponent as ɵy, AtftMeshModule as ɵz };
//# sourceMappingURL=atft.js.map
