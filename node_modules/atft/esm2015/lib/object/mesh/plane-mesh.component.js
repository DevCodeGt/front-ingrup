/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Component, forwardRef, Input } from '@angular/core';
import * as THREE from 'three';
import { AbstractMesh } from './abstract-mesh-3d';
import { AbstractObject3D } from '../abstract-object-3d';
import { RendererService } from '../../renderer/renderer.service';
export class PlaneMeshComponent extends AbstractMesh {
    /**
     * @param {?} rendererService
     */
    constructor(rendererService) {
        super(rendererService);
        this.rendererService = rendererService;
        /**
         * Width; that is, the length of the edges parallel to the X axis. Optional; defaults to 1.
         */
        this.width = 1.0;
        /**
         * Height; that is, the length of the edges parallel to the Y axis. Optional; defaults to 1.
         */
        this.height = 1.0;
        /**
         * Number of segmented rectangular faces along the width of the sides. Optional; defaults to 1.
         */
        this.widthSegments = 1;
        /**
         * Number of segmented rectangular faces along the height of the sides. Optional; defaults to 1.
         */
        this.heightSegments = 1;
    }
    /**
     * @protected
     * @return {?}
     */
    newObject3DInstance() {
        /** @type {?} */
        const geometry = new THREE.PlaneBufferGeometry(this.width, this.height, this.widthSegments, this.heightSegments);
        /** @type {?} */
        const material = this.getMaterial();
        /** @type {?} */
        const mesh = new THREE.Mesh(geometry, material);
        this.applyShadowProps(mesh);
        return mesh;
    }
}
PlaneMeshComponent.decorators = [
    { type: Component, args: [{
                selector: 'atft-plane-mesh',
                providers: [{ provide: AbstractObject3D, useExisting: forwardRef((/**
                         * @return {?}
                         */
                        () => PlaneMeshComponent)) }],
                template: '<ng-content></ng-content>'
            }] }
];
/** @nocollapse */
PlaneMeshComponent.ctorParameters = () => [
    { type: RendererService }
];
PlaneMeshComponent.propDecorators = {
    width: [{ type: Input }],
    height: [{ type: Input }],
    widthSegments: [{ type: Input }],
    heightSegments: [{ type: Input }]
};
if (false) {
    /**
     * Width; that is, the length of the edges parallel to the X axis. Optional; defaults to 1.
     * @type {?}
     */
    PlaneMeshComponent.prototype.width;
    /**
     * Height; that is, the length of the edges parallel to the Y axis. Optional; defaults to 1.
     * @type {?}
     */
    PlaneMeshComponent.prototype.height;
    /**
     * Number of segmented rectangular faces along the width of the sides. Optional; defaults to 1.
     * @type {?}
     */
    PlaneMeshComponent.prototype.widthSegments;
    /**
     * Number of segmented rectangular faces along the height of the sides. Optional; defaults to 1.
     * @type {?}
     */
    PlaneMeshComponent.prototype.heightSegments;
    /**
     * @type {?}
     * @protected
     */
    PlaneMeshComponent.prototype.rendererService;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicGxhbmUtbWVzaC5jb21wb25lbnQuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9hdGZ0LyIsInNvdXJjZXMiOlsibGliL29iamVjdC9tZXNoL3BsYW5lLW1lc2guY29tcG9uZW50LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7QUFBQSxPQUFPLEVBQUMsU0FBUyxFQUFFLFVBQVUsRUFBRSxLQUFLLEVBQUMsTUFBTSxlQUFlLENBQUM7QUFDM0QsT0FBTyxLQUFLLEtBQUssTUFBTSxPQUFPLENBQUM7QUFDL0IsT0FBTyxFQUFDLFlBQVksRUFBQyxNQUFNLG9CQUFvQixDQUFDO0FBQ2hELE9BQU8sRUFBQyxnQkFBZ0IsRUFBQyxNQUFNLHVCQUF1QixDQUFDO0FBRXZELE9BQU8sRUFBQyxlQUFlLEVBQUMsTUFBTSxpQ0FBaUMsQ0FBQztBQU9oRSxNQUFNLE9BQU8sa0JBQW1CLFNBQVEsWUFBWTs7OztJQTBCbEQsWUFDWSxlQUFnQztRQUUxQyxLQUFLLENBQUMsZUFBZSxDQUFDLENBQUM7UUFGYixvQkFBZSxHQUFmLGVBQWUsQ0FBaUI7Ozs7UUFyQjVDLFVBQUssR0FBRyxHQUFHLENBQUM7Ozs7UUFNWixXQUFNLEdBQUcsR0FBRyxDQUFDOzs7O1FBTWIsa0JBQWEsR0FBRyxDQUFDLENBQUM7Ozs7UUFNbEIsbUJBQWMsR0FBRyxDQUFDLENBQUM7SUFNbkIsQ0FBQzs7Ozs7SUFFUyxtQkFBbUI7O2NBQ3JCLFFBQVEsR0FBRyxJQUFJLEtBQUssQ0FBQyxtQkFBbUIsQ0FBQyxJQUFJLENBQUMsS0FBSyxFQUFFLElBQUksQ0FBQyxNQUFNLEVBQUUsSUFBSSxDQUFDLGFBQWEsRUFBRSxJQUFJLENBQUMsY0FBYyxDQUFDOztjQUMxRyxRQUFRLEdBQUcsSUFBSSxDQUFDLFdBQVcsRUFBRTs7Y0FDN0IsSUFBSSxHQUFHLElBQUksS0FBSyxDQUFDLElBQUksQ0FBQyxRQUFRLEVBQUUsUUFBUSxDQUFDO1FBQy9DLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUM1QixPQUFPLElBQUksQ0FBQztJQUNkLENBQUM7OztZQTNDRixTQUFTLFNBQUM7Z0JBQ1QsUUFBUSxFQUFFLGlCQUFpQjtnQkFDM0IsU0FBUyxFQUFFLENBQUMsRUFBQyxPQUFPLEVBQUUsZ0JBQWdCLEVBQUUsV0FBVyxFQUFFLFVBQVU7Ozt3QkFBQyxHQUFHLEVBQUUsQ0FBQyxrQkFBa0IsRUFBQyxFQUFDLENBQUM7Z0JBQzNGLFFBQVEsRUFBRSwyQkFBMkI7YUFDdEM7Ozs7WUFOTyxlQUFlOzs7b0JBWXBCLEtBQUs7cUJBTUwsS0FBSzs0QkFNTCxLQUFLOzZCQU1MLEtBQUs7Ozs7Ozs7SUFsQk4sbUNBQ1k7Ozs7O0lBS1osb0NBQ2E7Ozs7O0lBS2IsMkNBQ2tCOzs7OztJQUtsQiw0Q0FDbUI7Ozs7O0lBR2pCLDZDQUEwQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7Q29tcG9uZW50LCBmb3J3YXJkUmVmLCBJbnB1dH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCAqIGFzIFRIUkVFIGZyb20gJ3RocmVlJztcclxuaW1wb3J0IHtBYnN0cmFjdE1lc2h9IGZyb20gJy4vYWJzdHJhY3QtbWVzaC0zZCc7XHJcbmltcG9ydCB7QWJzdHJhY3RPYmplY3QzRH0gZnJvbSAnLi4vYWJzdHJhY3Qtb2JqZWN0LTNkJztcclxuaW1wb3J0IHthcHBsaWVkQ29sb3J9IGZyb20gJy4uLy4uL3V0aWwvYXBwbGllZC1jb2xvcic7XHJcbmltcG9ydCB7UmVuZGVyZXJTZXJ2aWNlfSBmcm9tICcuLi8uLi9yZW5kZXJlci9yZW5kZXJlci5zZXJ2aWNlJztcclxuXHJcbkBDb21wb25lbnQoe1xyXG4gIHNlbGVjdG9yOiAnYXRmdC1wbGFuZS1tZXNoJyxcclxuICBwcm92aWRlcnM6IFt7cHJvdmlkZTogQWJzdHJhY3RPYmplY3QzRCwgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gUGxhbmVNZXNoQ29tcG9uZW50KX1dLFxyXG4gIHRlbXBsYXRlOiAnPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PidcclxufSlcclxuZXhwb3J0IGNsYXNzIFBsYW5lTWVzaENvbXBvbmVudCBleHRlbmRzIEFic3RyYWN0TWVzaCB7XHJcblxyXG4gIC8qKlxyXG4gICAqIFdpZHRoOyB0aGF0IGlzLCB0aGUgbGVuZ3RoIG9mIHRoZSBlZGdlcyBwYXJhbGxlbCB0byB0aGUgWCBheGlzLiBPcHRpb25hbDsgZGVmYXVsdHMgdG8gMS5cclxuICAgKi9cclxuICBASW5wdXQoKVxyXG4gIHdpZHRoID0gMS4wO1xyXG5cclxuICAvKipcclxuICAgKiBIZWlnaHQ7IHRoYXQgaXMsIHRoZSBsZW5ndGggb2YgdGhlIGVkZ2VzIHBhcmFsbGVsIHRvIHRoZSBZIGF4aXMuIE9wdGlvbmFsOyBkZWZhdWx0cyB0byAxLlxyXG4gICAqL1xyXG4gIEBJbnB1dCgpXHJcbiAgaGVpZ2h0ID0gMS4wO1xyXG5cclxuICAvKipcclxuICAgKiBOdW1iZXIgb2Ygc2VnbWVudGVkIHJlY3Rhbmd1bGFyIGZhY2VzIGFsb25nIHRoZSB3aWR0aCBvZiB0aGUgc2lkZXMuIE9wdGlvbmFsOyBkZWZhdWx0cyB0byAxLlxyXG4gICAqL1xyXG4gIEBJbnB1dCgpXHJcbiAgd2lkdGhTZWdtZW50cyA9IDE7XHJcblxyXG4gIC8qKlxyXG4gICAqIE51bWJlciBvZiBzZWdtZW50ZWQgcmVjdGFuZ3VsYXIgZmFjZXMgYWxvbmcgdGhlIGhlaWdodCBvZiB0aGUgc2lkZXMuIE9wdGlvbmFsOyBkZWZhdWx0cyB0byAxLlxyXG4gICAqL1xyXG4gIEBJbnB1dCgpXHJcbiAgaGVpZ2h0U2VnbWVudHMgPSAxO1xyXG5cclxuICBjb25zdHJ1Y3RvcihcclxuICAgIHByb3RlY3RlZCByZW5kZXJlclNlcnZpY2U6IFJlbmRlcmVyU2VydmljZVxyXG4gICkge1xyXG4gICAgc3VwZXIocmVuZGVyZXJTZXJ2aWNlKTtcclxuICB9XHJcblxyXG4gIHByb3RlY3RlZCBuZXdPYmplY3QzREluc3RhbmNlKCk6IFRIUkVFLk1lc2gge1xyXG4gICAgY29uc3QgZ2VvbWV0cnkgPSBuZXcgVEhSRUUuUGxhbmVCdWZmZXJHZW9tZXRyeSh0aGlzLndpZHRoLCB0aGlzLmhlaWdodCwgdGhpcy53aWR0aFNlZ21lbnRzLCB0aGlzLmhlaWdodFNlZ21lbnRzKTtcclxuICAgIGNvbnN0IG1hdGVyaWFsID0gdGhpcy5nZXRNYXRlcmlhbCgpO1xyXG4gICAgY29uc3QgbWVzaCA9IG5ldyBUSFJFRS5NZXNoKGdlb21ldHJ5LCBtYXRlcmlhbCk7XHJcbiAgICB0aGlzLmFwcGx5U2hhZG93UHJvcHMobWVzaCk7XHJcbiAgICByZXR1cm4gbWVzaDtcclxuICB9XHJcblxyXG59XHJcbiJdfQ==